# C++ 整理

[TOC]

## 1. C++ 编译过程

### 1.1 预编译

- 宏函数：在预编译时把所有宏名用宏体来替换
- define

### 1.2 编译

- 内联函数：在编译时进行代码插入，省区函数调用开销，提高效率
- const
- 命名倾轧（name mangling）：同名函数重载，在编译阶段更改函数名来区分参数不同的同名函数
- 虚函数表
- 数组指针
- 静态存储区的内容
- const_cast, reinterpret_cast, static_cast

### 1.3 汇编



### 1.4 链接



## 2. 内存管理

### 2.1 全局/静态存储区

- 静态全局变量，静态局部变量，全局变量：程序结束回收内存；
- 类静态成员变量：当超出类作用域时回收内存；



### 2.2 常量存储区

存放const常量，不允许修改



### 2.3 自由存储区

由malloc分配的内存块



### 2.4 栈

由操作系统自动分配释放，存放函数的参数值，存放在一级缓存

- 局部变量：出了作用域回收内存



### 2.5 堆

由程序员分配释放，存放在二级缓存

- new：new分配的内存块存放在堆上



## 3. 排序



## 4. vector

寻找最小元素

```c++
*min_element(sweetness.begin(),sweetness.end());
```

统计和：

~~~c++
accumulate(sweetness.begin(),sweetness.end(), 0)
~~~



## 5. 动态多态和静态多态

[C++动态多态详解及三个示例_写一个多态的例子 c++-CSDN博客](https://blog.csdn.net/h799710/article/details/112627090)



## 6. 虚函数和多态

**虚函数表指针（vptr）**：当类中存在虚函数时，会自动创建隐形的虚函数表指针，该指针是成员变量，占用类对象的内存空间；

**虚函数表（vtbl）**：当类中存在至少一个虚函数时，在**编译**期间会自动创建虚函数表，在编译链接生成可执行文件后，类和其对应的虚函数表会被保存到可执行文件中，可执行文件执行时一并被加载到内存中；

**vptr被赋值的时机以及vptr和vbtl的关系** ：在**编译**期间，编译器会向类的构造函数中安插为vptr赋值的语句。当创建该类对象时会调用该类的构造函数，因为构造函数中有给vptr赋值的语句从而使vptr指向类的vtbl

~~~c++
//伪代码如下
A(){
	vptr = &A::vftable;  //使vptr指向类A的vtbl
	//......
}
~~~

**类对象在内存中的布局** ：

~~~c++
class A
{
public:
	virtual ~A(){}
	void func1(){}
	void func2(){}
	virtual void vfunc1(){}
	virtual void vfunc2(){}
private:
    int m_a;
    int m_b;
}
~~~

当生成A对象时，就可以看一看类A对象在内存中的布局：

<img src="Image\1710740538961.png" alt="1710740538961" style="zoom: 80%;" />

编译器会向其中插入vptr，同时，vptr会指向类A的vtbl

<img src="Image\1710740768531.png" alt="1710740768531" style="zoom:80%;" />

虚函数表的三个指针分别指向类的三个虚函数vfunc1，vfunc和~A，它们都是类A的组成部分，不占用类A对象的内存空间

<img src="Image\1710740876519.png" alt="1710740876519" style="zoom:80%;" />





**构造函数不能为虚函数** ：如果构造函数时虚函数，那么调用构造函数就需要去找vptr，而此时vptr还没有初始化，因此**构造函数不可以是虚函数**。

**析构函数常常是虚函数** ：

- 若析构函数是虚函数，delete 时，基类和子类都会被释放；
- 若析构函数不是虚函数，delete 时，只有基类会被释放，而子类没有释放，存在内存泄漏的隐患。



**多态性** ：函数重载是**静态多态**，**动态多态**是指父类有一个虚函数，子类中有该虚函数的重写，当通过父类指针new一个子类对象如 $\text{ Base* pBase = new A;}$​  ，或通过父类引用来绑定一个子类对象时，如果用这个父类指针来调用虚函数那么调用的其实是子类的虚函数。 动态多态必须存在**虚函数**，没有**虚函数**绝对不可能存在**动态多态**。



**虚函数的工作原理和多态性的体现** ： 

![1710742184270](Image\1710742184270.png)
