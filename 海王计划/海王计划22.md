# 海王计划22

[TOC]



## [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

**关键词**：多维动态规划

~~~c++
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        vector<int> cnt(triangle.size());
        cnt[0] = triangle[0][0];

        for(int i = 1; i<triangle.size(); i++){
            for(int j = i; j>=0; j--){
                if(j > 0 && j < i){
                    cnt[j] = min(cnt[j-1] + triangle[i][j], cnt[j] + triangle[i][j]);
                }
                else if(j == 0){
                    cnt[j] = cnt[j] + triangle[i][j];
                }
                else{
                    cnt[j] = cnt[j-1] + triangle[i][j];
                }
            }
        }

        int res = INT_MAX;

        for(int i = 0; i<cnt.size(); i++){
            res = min(res, cnt[i]);
        }

        return res;
    }
};
~~~



## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

**关键词**：多维动态规划

~~~c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        vector<int> cnt(grid[0].size(), 0);
        cnt[0] = grid[0][0];
        for(int i = 1; i < grid[0].size(); i++){
            cnt[i] = cnt[i - 1] + grid[0][i];
        }

        for(int i = 1; i < grid.size(); i++){
            cnt[0] += grid[i][0];
            for(int j = 1; j < grid[0].size(); j++){
                cnt[j] = min(cnt[j-1] + grid[i][j], cnt[j] + grid[i][j]);
            }
        }

        return cnt[grid[0].size()-1];
    }
};
~~~



## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

**关键词**：多维动态规划

~~~c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if(obstacleGrid[0][0] == 1) return 0;
        
        vector<int> cnt(obstacleGrid[0].size(), 0);
        cnt[0] = 1;
        for(int i = 1; i<obstacleGrid[0].size(); i++){
            if(obstacleGrid[0][i] == 1){
                cnt[i] = 0;
            }
            else{
                cnt[i] = min(1, cnt[i-1]);
            }
        }

        for(int i = 1; i<obstacleGrid.size(); i++){
            if(obstacleGrid[i][0] == 1){
                cnt[0] = 0;
            }
            for(int j = 1; j<obstacleGrid[0].size(); j++){
                if(obstacleGrid[i][j] == 1){
                    cnt[j] = 0;
                }
                else{
                    cnt[j] = cnt[j-1] + cnt[j];
                }
            }
        }

        return cnt[obstacleGrid[0].size()-1];
    }
};
~~~

