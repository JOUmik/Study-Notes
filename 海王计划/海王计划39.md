# 海王计划39

[TOC]



## [549. 二叉树最长连续序列 II](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence-ii/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int longestConsecutive(TreeNode* root) {
        stack<TreeNode*> s;
        s.push(root);
        int res = 0;
        while(!s.empty()){
            TreeNode* curNode = s.top();
            s.pop();
            if(curNode!=nullptr){
                 res = max(res, max(dfs(curNode->left, curNode, 0, false) + dfs(curNode->right, curNode, 0, true) + 1, 
                                    dfs(curNode->left, curNode, 0, true) + dfs(curNode->right, curNode, 0, false) + 1));
                 s.push(curNode->left);
                 s.push(curNode->right);
            }
        }

        return res;
    }

    int dfs(TreeNode* node, TreeNode* parent, int length, bool isIncrease){
        if(node == nullptr) return length;
        if(isIncrease){
            if(node->val == parent->val+1){
                 length++;
                 return max(dfs(node->left, node, length, true), dfs(node->right, node, length, true));
            }
        }
        else{
            if(node->val + 1 == parent->val){
                length++;
                return max(dfs(node->left, node, length, false), dfs(node->right, node, length, false));
            }
        }
        return length;
    }
};
~~~



## [250. 统计同值子树](https://leetcode.cn/problems/count-univalue-subtrees/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countUnivalSubtrees(TreeNode* root) {
        stack<TreeNode*> s;
        int res = 0;
        s.push(root);
        while(!s.empty()){
            TreeNode* node = s.top();
            s.pop();

            if(node){
                int num = 0;
                int cnt = dfs(node, num);
                if(cnt == -1){
                    s.push(node->left);
                    s.push(node->right);
                }
                else res += cnt;
            }
        }

        return res;
    }

    int dfs(TreeNode* node, int& num){
        if(node == nullptr) return num;
        if((!node->left || node->val == node->left->val) && (!node->right || node->val == node->right->val)){
            num++;
            int numL = dfs(node->left, num);
            int numR = dfs(node->right, num);
            if(numL == -1 || numR == -1) return -1;
            else return num;
        }
        return -1;
    }
};
~~~



## [1120. 子树的最大平均值](https://leetcode.cn/problems/maximum-average-subtree/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    double maximumAverageSubtree(TreeNode* root) {
       return maxAverage(root).maxAverage;
   }
private:
   struct State {
       int nodeCount;

       int valueSum;

       double maxAverage;
   };

   State maxAverage(TreeNode* root) {
       if (!root) return {0, 0, 0};

       State left = maxAverage(root->left);
       State right = maxAverage(root->right);

       int nodeCount = left.nodeCount + right.nodeCount + 1;
       int sum = left.valueSum + right.valueSum + root->val;
       double maxAverage = max((1.0 * (sum)) / nodeCount,
                            max(right.maxAverage, left.maxAverage)
                           );

       return {nodeCount, sum, maxAverage};
   }
};
~~~

