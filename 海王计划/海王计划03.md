# 海王计划03

# [909. 蛇梯棋](https://leetcode.cn/problems/snakes-and-ladders/)

**关键词**：图，BFS

~~~c++
class Solution {
public:
    pair<int, int> getLocation(int id, int l){
        int r = (id - 1) / l, c = (id - 1) % l;

        if(r % 2 == 1){
            c = l - 1 - c;
        } 

        return {l - 1 - r, c};
    } 

    int snakesAndLadders(vector<vector<int>>& board) {
        int l = board.size();

        vector<int> walked(l * l); //如果走过，则walked[id]为false

        queue<pair<int, int>> q;  //pair<A, B> 中A保存走过的id，B存储走到该id所需最小步数

        q.emplace(1, 0);

        while(!q.empty()){
            pair<int, int> temp = q.front();
            q.pop();

            for(int i = 1; i <= 6; i++){
                int id = temp.first + i;

                if(id > l * l){
                    //超出边界则退出
                    break;
                }

                pair<int, int> p = getLocation(id, l);

                if(board[p.first][p.second] != -1){
                    id = board[p.first][p.second];
                }

                if(id == l * l){
                    return temp.second + 1;
                }

                if(!walked[id - 1]){ //剪枝
                    walked[id - 1] = true;
                    q.emplace(id, temp.second + 1);
                }
            }
        }

        return -1;
    }
};
~~~



## [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

**关键词**：图，BFS

~~~c++
class Solution {
public:
    int calDif(string A, string B){
        int res = 0;
        
        for(int i = 0; i < A.length(); i++){
            if(A[i] != B[i]) res++;
        }

        return res;
    }

    int minMutation(string startGene, string endGene, vector<string>& bank) {
        queue<pair<string, int>> q;  //pair<A,B> A中存储字符串， B中存储变为A经历了几次变异
        queue<vector<int>> q_walked;   //记录遍历过的基因序列
        vector<int> v(bank.size());
        
        q.emplace(startGene, 0);
        q_walked.emplace(v);

        while(!q.empty()){
            auto temp = q.front();
            q.pop();

            auto walked = q_walked.front();
            q_walked.pop();

            for(int i = 0; i < bank.size(); i++){
                if(walked[i] == 0){
                    int num = calDif(temp.first, bank[i]);

                    //只有一个字符不同，可以变异
                    if(num == 1){
                        if(bank[i] == endGene){
                            return temp.second + 1;
                        }

                        auto n_walked = walked;
                        n_walked[i] = 1;

                        q.emplace(bank[i], temp.second + 1);
                        q_walked.emplace(n_walked);                   
                    }
                }
            }
        }

        return -1;
    }
};
~~~



