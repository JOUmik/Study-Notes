# 海王计划47

[TOC]



## [490. 迷宫](https://leetcode.cn/problems/the-maze/)

**关键词**：BFS

~~~c++
class Solution {
public:
    bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int m = maze.size(), n = maze[0].size();
        int des_i =  destination[0] * 100 + destination[1];
        unordered_set<int> cnt;
        stack<vector<int>> s;
        s.push(start);
        while(!s.empty()){
            vector<int> temp = s.top();
            s.pop();
            int index = temp[0]*100+temp[1];
            if(index == des_i) return true;
            if(cnt.find(index) != cnt.end()) continue;
            cnt.emplace(index);
            int left = 0, right = 0, up = 0, down = 0;
            //左
            while(temp[1] - left >= 1 && maze[temp[0]][temp[1] - left - 1] == 0){
                left++;
            }
            //右
            while(temp[1] + right <= n-2 && maze[temp[0]][temp[1] + right + 1] == 0){
                right++;
            }
            //上
            while(temp[0] - up >= 1 && maze[temp[0] - up - 1][temp[1]] == 0){
                up++;
            }
            //下
            while(temp[0] + down <= m-2 && maze[temp[0] + down + 1][temp[1]] == 0){
                down++;
            }

            if(left) s.emplace(vector<int>{temp[0], temp[1]-left});
            if(right) s.emplace(vector<int>{temp[0], temp[1]+right});
            if(up) s.emplace(vector<int>{temp[0]-up, temp[1]});
            if(down) s.emplace(vector<int>{temp[0]+down, temp[1]});
        }

        return false;
    }
};
~~~



## [505. 迷宫 II](https://leetcode.cn/problems/the-maze-ii/)

**关键词**：BFS

~~~c++
class Solution {
public:
    int shortestDistance(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {
        int m = maze.size(), n = maze[0].size();
        int des_i =  destination[0] * 100 + destination[1];
        unordered_map<int, int> cnt;
        queue<pair<vector<int>, int>> s;
        s.emplace(start, 0);
        int res = -1;

        while(!s.empty()){
            auto p = s.front();
            s.pop();
            vector<int> temp = p.first;
            int Passed = p.second;

            int index = temp[0]*100+temp[1];
            if(index == des_i) {
                if(res >= 0) res = min(res, Passed);
                else res = Passed;
            }
            if(cnt.find(index) != cnt.end()){
                if(cnt[index] <= Passed) continue;
            }
            cnt[index] = Passed;

            int left = 0, right = 0, up = 0, down = 0;
            //左
            while(temp[1] - left >= 1 && maze[temp[0]][temp[1] - left - 1] == 0){
                left++;
            }
            //右
            while(temp[1] + right <= n-2 && maze[temp[0]][temp[1] + right + 1] == 0){
                right++;
            }
            //上
            while(temp[0] - up >= 1 && maze[temp[0] - up - 1][temp[1]] == 0){
                up++;
            }
            //下
            while(temp[0] + down <= m-2 && maze[temp[0] + down + 1][temp[1]] == 0){
                down++;
            }

            if(left) s.emplace(vector<int>{temp[0], temp[1]-left}, Passed + left);
            if(right) s.emplace(vector<int>{temp[0], temp[1]+right}, Passed + right);
            if(up) s.emplace(vector<int>{temp[0]-up, temp[1]}, Passed + up);
            if(down) s.emplace(vector<int>{temp[0]+down, temp[1]}, Passed + down);
        }

        return res;
    }
};
~~~



## [499. 迷宫 III](https://leetcode.cn/problems/the-maze-iii/)

**关键词**：优先队列

~~~c++
struct node{
    int x,y,d;string path;
    node(int x,int y,int d,string path):x(x),y(y),d(d),path(path){}
    bool operator<(const node&t)const{return(d==t.d)?path>t.path:d>t.d;}
};
class Solution{
public:
    int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};char ds[4]={'r','d','l','u'};
    string findShortestWay(vector<vector<int>>&maze,vector<int>&ball,vector<int>&hole) {
        priority_queue<node>q;
        int n=maze.size(),m=maze[0].size();
        vector<vector<int>>dis(n,vector<int>(m,1e9));
        auto end=[&](int x,int y){return x==hole[0] && y==hole[1];};        
        auto ok=[&](int x,int y){return 0<=x&&x<n && 0<=y&&y<m && !maze[x][y];};        
        q.push(node(ball[0],ball[1],0,"")),dis[ball[0]][ball[1]]=0;
        while(!q.empty()){
            auto u=q.top();q.pop();
            int x=u.x,y=u.y,d=u.d;string s=u.path;
            if(end(x,y))return s;
            for(int i=0;i<4;i++){
                int nx=x,ny=y,nd=d;string ns=s+ds[i];
                while(ok(nx+dx[i],ny+dy[i])){
                    nx+=dx[i],ny+=dy[i],nd++;
                    if(end(nx,ny))break;
                }
                if(d<nd && nd<=dis[nx][ny])
                    q.push(node(nx,ny,nd,ns)),dis[nx][ny]=nd;                
            }
        }
        return "impossible";
    }
};
~~~

