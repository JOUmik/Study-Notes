# 海王计划28

[TOC]



## [159. 至多包含两个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)

**关键词**：滑动窗口

~~~c++
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        int res = 0;
        int l = 0;
        unordered_map<char, int> umap;

        for(int r = 0; r < s.size(); r++){
            umap[s[r]] += 1;
            if(umap.size() <= 2){
                res = max(res, r - l + 1);
            }
            else{
                while(umap.size() > 2){
                    umap[s[l]]--;
                    if(umap[s[l]] == 0) umap.erase(s[l]);
                    l++;
                }
            }
        }

        return res;
    }
};
~~~



## [340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)

**关键词**：滑动窗口

~~~c++
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        int res = 0;
        int l = 0;
        unordered_map<char, int> umap;

        for(int r = 0; r < s.size(); r++){
            umap[s[r]] += 1;
            if(umap.size() <= k){
                res = max(res, r - l + 1);
            }
            else{
                while(umap.size() > k){
                    umap[s[l]]--;
                    if(umap[s[l]] == 0) umap.erase(s[l]);
                    l++;
                }
            }
        }

        return res;
    }
};
~~~



## [1100. 长度为 K 的无重复字符子串](https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/)

**关键词**：滑动窗口

~~~c++
class Solution {
public:
    int numKLenSubstrNoRepeats(string s, int k) {
        if(s.size() < k) return 0;

        unordered_map<char, int> umap;
        int l = 0;
        int res = 0;
        for(int i = 0; i<s.size(); i++){
            umap[s[i]] += 1;
            if(umap[s[i]] > 1){
                while(s[l] != s[i]){
                    umap.erase(s[l]);
                    l++;
                }
                l++;
                umap[s[i]] = 1;
            }
            else if(i - l + 1 == k){
                umap.erase(s[l]);
                l++;
                res++;
            }
        }

        return res;
    }
};
~~~



## [487. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/)

**关键词**：滑动窗口

~~~c++
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int l = 0;
        int res = 0;

        for(int r = 0; r < nums.size(); r++){
            if(nums[r] == 1){
                res = max(res, r - l + 1);
            }
            else{
                int temp = r - 1;
                while(temp >= l && nums[temp] != 0){
                    temp--;
                }
                if(temp >= l && nums[temp] == 0) l = temp + 1;
                res = max(res, r - l + 1);
            }
        }

        return res;
    }
};
~~~

