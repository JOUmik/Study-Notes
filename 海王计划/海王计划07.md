# 海王计划07

[TOC]



## 46. 全排列

**关键词**：回溯， DFS

~~~c++
class Solution {
public:
    vector<vector<int>> res;

    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> v;

        dfs(v, nums);

        return res;
    }

    void dfs(vector<int>& v, vector<int>& nums){
        for(int i = 0; i < nums.size(); i++){
            bool checked = false;

            for(int j = 0; j < v.size(); j++){
                if(v[j] == nums[i]){
                    checked = true;
                    break;
                }
            }

            if(checked) continue;

            v.push_back(nums[i]);

            if(v.size() == nums.size()){
                res.push_back(v);
            }
            else{
                dfs(v, nums);
            }

            v.pop_back();
        }
    }
};
~~~



## 39. 组合总和

**关键词**：回溯，DFS

~~~c++
class Solution {
public:
    vector<vector<int>> res;

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> v;

        dfs(v, candidates, target, 0, 0);

        return res;
    }

    void dfs(vector<int>& v, vector<int>& candidates, int target, int sum, int begin_i){
        for(int i = begin_i; i < candidates.size(); i++){
            v.push_back(candidates[i]);

            sum += candidates[i];

            if(sum < target){
                dfs(v, candidates, target, sum, i);
            }
            else if(sum == target){
                res.push_back(v);
            }
            
            v.pop_back();
            sum -= candidates[i];
        }
    }
};
~~~



## 52. N皇后II

**关键词**：回溯，DFS

~~~c++
class Solution {
public:
    int res = 0;

    int totalNQueens(int n) {
        vector<int> v;  //存储每行的皇后位置

        dfs(v, n, 0);

        return res;
    }
 
    void dfs(vector<int>& v, int n, int index){
        for(int i = 0; i < n; i++){
            bool flag = false;

            for(int j = 0; j < v.size() && !flag; j++){
                //皇后问题能否放置的判断
                if(i == v[j]) flag = true;;
                if(abs(index - j) == abs(i - v[j])) flag = true;
            }

            if(flag) continue;

            v.push_back(i);
            index++;

            if(index == n){
                res++;
            }
            else{
                dfs(v, n, index);
            }

            v.pop_back();
            index--;
        }
    }
};
~~~

