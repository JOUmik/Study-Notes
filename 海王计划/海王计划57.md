# 海王计划57

[TOC]



## [1087. 花括号展开](https://leetcode.cn/problems/brace-expansion/)

**关键词：**回溯

~~~c++
class Solution {
public:
    vector<string>ans;
    vector<string> expand(string s) {
        string path;
        string s1;
        for(char c:s){
            if(c!=',')s1.push_back(c);
        }
        dfs(0,path,s1);
        sort(ans.begin(),ans.end());
        return ans;
    }
    void dfs(int begIdx,string &path,string&s){
        int n=s.size();
        while(begIdx<n&&s[begIdx]!='{'){
            path.push_back(s[begIdx]);
            begIdx++;
        }
        if(begIdx==n){
            ans.push_back(path);
            return;
        }
        int endIdx=s.find("}",begIdx);
        for(int i=begIdx+1;i<endIdx;i++){
            string copy=path;
            copy.push_back(s[i]);
            dfs(endIdx+1,copy,s);
        }
    }
};
~~~



## [1150. 检查一个数是否在数组中占绝大多数](https://leetcode.cn/problems/check-if-a-number-is-majority-element-in-a-sorted-array/)

~~~c++
class Solution {
public:
    bool isMajorityElement(vector<int>& nums, int target) {
        int val = nums[(nums.size()-1)/2];
        if (val != target) return false;

        // 找到target首次出现的位置
        int left = 0, right = nums.size()-1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= val) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        int leftresult = left;

        // 找到target最后一次出现的位置
        left = 0, right = nums.size();
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > val) {
                right = mid;
            } else {
                left = mid+1;
            }
        }
        int rightresult = left - 1;

        return rightresult - leftresult + 1 > nums.size() / 2;
    }
};
~~~

