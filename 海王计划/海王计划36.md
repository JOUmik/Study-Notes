# 海王计划36

[TOC]



## [346. 数据流中的移动平均值](https://leetcode.cn/problems/moving-average-from-data-stream/)

~~~c++
class MovingAverage {
public:
    MovingAverage(int i_size) {
        size = i_size;
        sum = 0;
    }
    
    double next(int val) {
        if(q.size() == size){
            sum -= q.front();
            q.pop();
        }

        q.emplace(val);
        sum+=val;
        return sum/q.size();
    }

private:
    int size;
    double sum;
    queue<int> q;
};

/**
 * Your MovingAverage object will be instantiated and called as such:
 * MovingAverage* obj = new MovingAverage(size);
 * double param_1 = obj->next(val);
 */
~~~





## [1429. 第一个唯一数字](https://leetcode.cn/problems/first-unique-number/)

~~~c++
class FirstUnique {
public:
    FirstUnique(vector<int>& nums) {
        for(int i = 0; i<nums.size(); i++){
            if(s.find(nums[i]) == s.end()){
                v.emplace_back(nums[i]);
            }
            s[nums[i]]++;
            q.push(nums[i]);
        }
    }
    
    int showFirstUnique() {
        if(s.size() == 0) return -1;
        else{
            for(int i = offset; i < v.size(); i++){
                if(s.find(v[i])->second == 1){
                    offset = i;
                    return v[i];
                }
            }
            offset = v.size();
            return -1;
        }
    }
    
    void add(int value) {
        if(s.find(value) == s.end()){
                v.emplace_back(value);
        }
        s[value]++;
        q.push(value);
    }

private:
    unordered_map<int, int> s;
    queue<int> q;
    vector<int> v;
    int offset = 0;
};

/**
 * Your FirstUnique object will be instantiated and called as such:
 * FirstUnique* obj = new FirstUnique(nums);
 * int param_1 = obj->showFirstUnique();
 * obj->add(value);
 */
~~~





## [708. 循环有序列表的插入](https://leetcode.cn/problems/insert-into-a-sorted-circular-linked-list/)

~~~c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;

    Node() {}

    Node(int _val) {
        val = _val;
        next = NULL;
    }

    Node(int _val, Node* _next) {
        val = _val;
        next = _next;
    }
};
*/

class Solution {
public:
    Node* insert(Node* head, int insertVal) {
        if(head == nullptr){
            Node* res = new Node(insertVal);
            res->next = res;
             return res;
        }

        Node* node = head;
        Node* begin, *end;
        
        while(true){
            if(node->val > node->next->val){
                end = node;
                begin = node->next;
                break;
            }
            else if(node->next == head){
                end = node;
                begin = head;
                break;
            }
            node = node->next;
        }

        if(insertVal <= begin->val || end->val <= insertVal){
            Node* temp = new Node(insertVal);
            
            end->next = temp;
            temp->next = begin;

            return head;
        }

        while(true){
            if(begin->val <= insertVal && begin->next->val > insertVal){
                begin->next = new Node(insertVal, begin->next);
                break;
            }
            begin = begin->next;
        }

        return head;
    }
};
~~~

