# 海王计划27

[TOC]



## [1427. 字符串的左右移](https://leetcode.cn/problems/perform-string-shifts/)

~~~c++
class Solution {
public:
    string stringShift(string s, vector<vector<int>>& shift) {
        int bias = 0;  //负数向左，正数向右

        for(int i = 0; i < shift.size(); i++){
            shift[i][0] == 0 ? bias -= shift[i][1] : bias += shift[i][1];
        }

        if(bias < 0){
            bias = abs(bias) % s.size();
            string str1(s, 0, bias);
            string str2(s, bias, s.size() - bias);
            return str2 + str1;
        }
        else{
            bias = bias % s.size();
            string str1(s, 0, s.size() - bias);
            string str2(s, s.size() - bias, bias);
            return str2 + str1;
        }
    }
};
~~~



## [161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/)

~~~c++
class Solution {
public:
    bool isOneEditDistance(string s, string t) {
        int n = s.size(), m = t.size();

        if(n*m == 0){
            if(n+m == 1) return true;
            else return false;
        }

        if(abs(n-m) >= 2) return false;

        if(n == m){
            int cnt = 0;
            for(int i = 0; i<n ; i++){
                if(s[i] != t[i]){
                    cnt++;
                    if(cnt > 1) return false;
                }
            }
            if(cnt == 1) return true;
            else return false;
        }
        else{
            if(n<m){
                swap(s, t);
                swap(n, m);
            }
            int cnt = 0;
            for(int i = 0; i<n; i++){
                if(s[i] != t[i - cnt]){
                    cnt++;
                    if(cnt > 1) return false;
                }
            }
            if(cnt == 1) return true;
            else return false;
        }
    }
};
~~~



## [186. 反转字符串中的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)

~~~c++
class Solution {
public:
    void reverseWords(vector<char>& s) {
        reverse(s, 0, s.size()-1);

        int begin = 0;
        for(int i = 0; i<s.size(); i++){
            if(s[i] == ' '){
                reverse(s, begin, i-1);
                begin = i+1;
            }
        }
        reverse(s, begin, s.size()-1);
    }

    void reverse(vector<char>& s, int begin, int end){
        while(begin<end){
            int temp = s[end];
            s[end] = s[begin];
            s[begin] = temp;
            end--;
            begin++;
        }
    }
};
~~~



## [1055. 形成字符串的最短路径](https://leetcode.cn/problems/shortest-way-to-form-string/)

~~~c++
class Solution {
public:
    int shortestWay(string source, string target) {
        int index = 0;
        int n = source.size();
        int res = 1;

        for(int i = 0; i < target.size(); i++){
            int temp = index;
            while(target[i] != source[index]){
                index++;
                if(index == n){
                    index = 0;
                    res++;
                }
                if(index == temp) return -1;
            }

            index++;
            if(index == n && i != target.size()-1){
                index = 0;
                res++;
            }
            continue;

        }

        return res;
    }
};
~~~

