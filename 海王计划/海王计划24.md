# 海王计划24

[TOC]



## [380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)

**关键词**：哈希表

~~~c++
class RandomizedSet {
public:
    RandomizedSet() {
        srand((unsigned int)time(NULL));
    }
    
    bool insert(int val) {
        if(indices.count(val)){
            return false;
        }
        int index = nums.size();
        nums.push_back(val);
        indices[val] = index;
        return true;
    }
    
    bool remove(int val) {
        if(!indices.count(val)){
            return false;
        }
        int index = indices[val];
        nums[index] = nums.back();
        indices[nums.back()] = index;
        nums.pop_back();
        indices.erase(val);
        return true;
    }
    
    int getRandom() {
        int index = rand() % nums.size();
        return nums[index];
    }

private:
    vector<int> nums;
    unordered_map<int, int> indices;
};

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj = new RandomizedSet();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
~~~



## [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

~~~c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        /** 
        *   基本思想：顺时针旋转90度后坐标变化为：column变为row，(matrix.length-1) - row变为column
        **/
        int l = matrix.size();

        for(int i = 0; i < l/2; i++){
            for(int j = 0; j < (l+1)/2; j++){
                int x = i, y = j;
                int origin = matrix[x][y];
                int index = 0;
                while(index < 4){
                    int tempt = matrix[y][l - 1 - x];
                    matrix[y][l - 1 - x] = origin;
                    origin = tempt;
                    tempt = x;
                    x = y;
                    y = l - 1 - tempt;
                    index++;
                }
            }
        }
    }
};
~~~



## [221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

~~~c++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        //cnt中存储以i作为左起点的边长
        vector<int> cnt(matrix[0].size());

        int res = 0;

        for(int i = 0; i<matrix[0].size(); i++){
            if(matrix[0][i] == '1'){
                cnt[i] = 1;
                res = max(res, cnt[i]);
            }
        }


        for(int i = 1; i<matrix.size(); i++){
            for(int j = 0; j<matrix[0].size(); j++){
                if(cnt[j] == 0 && matrix[i][j] == '1'){
                    cnt[j] = 1;
                    res = max(res, cnt[j]);
                    continue;
                }
                if(cnt[j] != 0){
                    if(j+cnt[j] == cnt.size()) continue;

                    int  LengthOfOne = 0;
                    bool AllOne = true;
                    for(int x = j; x < j + cnt[j]; x++){
                        if(matrix[i][x] == '0'){
                            AllOne = false;
                            break;
                        }
                        else{
                            LengthOfOne++;
                        }
                    }

                    if(AllOne){
                        for(int x = i - cnt[j]; x <= i; x++){
                            if(matrix[x][j + cnt[j]] == '0'){
                                AllOne = false;
                                break;
                            }
                        }
                        if(AllOne){
                            cnt[j]++;
                            res = max(res, cnt[j]);
                        }
                        
                    }
                    else{
                        res = max(res, cnt[j]);
                        cnt[j] = LengthOfOne;
                    }
                }
            }
        }

        return res*res;
    }
};
~~~



## [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

**关键词**：多维动态规划，滚动数组

~~~c++
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n = s1.size(), m = s2.size(), l = s3.size();

        if(n + m != l) return false;

        vector<bool> cnts(m+1, 0);
        cnts[0] = true;

        for(int i = 0; i <= n; i++){
            for(int j = 0; j <= m; j++){
                int p = i + j - 1;

                if(i > 0){
                    cnts[j] = cnts[j] && (s1[i-1] == s3[p]);
                }
                if(j > 0){
                    cnts[j] = cnts[j] || (cnts[j-1] && s2[j-1] == s3[p]);
                }
            }
        }

        return cnts[m];
    }
};
~~~

