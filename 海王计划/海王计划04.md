# 海王计划04

[TOC]



## 127. 单词接龙

**关键词**：双向图，BFS

~~~c++
class Solution {
public:
    unordered_map<string, int> wordId;
    vector<vector<int>> edge;
    int nodeNum = 0;

    //每个string对应一个index
    void addWord(string& word){
        if(!wordId.count(word)){
            wordId[word] = nodeNum;
            nodeNum++;

            edge.emplace_back();
        }
    }
    
    //建立图
    void addEdge(string& word){
        addWord(word);
        int id1 = wordId[word];

        //虚节点
        for(char& c : word){
            char temp = c;
            c = '*';  
            addWord(word);
            int id2 = wordId[word];

            edge[id1].push_back(id2);
            edge[id2].push_back(id1); //双向图
            c = temp;
        }
    }
    

    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        int res = 0;

        for(int i = 0; i < wordList.size(); i++){
            if(wordList[i] == endWord) break;
            if(wordList[i] != endWord && i == wordList.size() - 1) return res;
        }

        for(string& word : wordList){
            addEdge(word);
        }
        addEdge(beginWord);

        vector<int> dis(nodeNum, INT_MAX);

        int beginId = wordId[beginWord], endId = wordId[endWord];
        queue<int> q;

        dis[beginId] = 0;

        q.push(beginId);

        while(!q.empty()){
            int tem = q.front();
            q.pop();

            if(tem == endId){
                return dis[endId]/2 + 1;
            }
            else{
                for(int i : edge[tem]){
                    if(dis[i] == INT_MAX){
                        dis[i] = dis[tem] + 1;
                        q.push(i);
                    }
                }
            }
        }

        return res;

    }
};
~~~



## 208. 实现Trie（前缀树）

****

**关键词**：前缀树

~~~c++
class Trie {
public:
    Trie() {
        children.resize(26);
        isEnd = false;
    }
    
    void insert(string word) {
        Trie* node = this;
        for(char ch : word){
            int i = ch - 'a';
            if(node->children[i] == nullptr){
                node->children[i] = new Trie();
            }

            node = node->children[i];
        }

        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this->searchPrefix(word);
        return node != nullptr && node->isEnd;
    }
    
    bool startsWith(string prefix) {
        return this->searchPrefix(prefix) != nullptr;
    }

private:
    vector<Trie*> children;
    bool isEnd;

    Trie* searchPrefix(string prefix){
        Trie* node = this;
        for(char ch : prefix){
            int i = ch - 'a';

            if(node->children[i] != nullptr){
                node = node->children[i];
            }
            else{
                return nullptr;
            }
        }

        return node;
    }
};
~~~

