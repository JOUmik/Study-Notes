# 海王计划30

[TOC]



## [1165. 单行键盘](https://leetcode.cn/problems/single-row-keyboard/)

**关键词**：哈希表

~~~c++
class Solution {
public:
    int calculateTime(string keyboard, string word) {
        vector<int> nums(26);

        for(int i = 0; i < keyboard.size(); i++){
            nums[keyboard[i] - 'a'] = i;
        }

        int res = 0;

        int pre = 0;
        for(int i = 0; i < word.size(); i++){
            res += abs(nums[word[i] - 'a'] - pre);
            pre = nums[word[i] - 'a'];
        }

        return res;
    }
};
~~~



## [1133. 最大唯一数](https://leetcode.cn/problems/largest-unique-number/)

**关键词**：哈希表

~~~c++
class Solution {
public:
    int largestUniqueNumber(vector<int>& nums) {
        unordered_map<int, int> m;
        for (int num: nums) {
            ++m[num];
        }

        int mx = -1;
        for (auto& [k, v]: m) {
            if (v == 1 && k > mx) {
                mx = k;
            }
        }
        return mx;
    }
};
~~~



## [1426. 数元素](https://leetcode.cn/problems/counting-elements/)

**关键词**：哈希表

~~~c++
class Solution {
public:
    int countElements(vector<int>& arr) {
        unordered_set<int> uset;
        for(int a : arr){
            uset.insert(a);
        }

        int res = 0;
        for(int a : arr){
            if(uset.find(a + 1) != uset.end()){
                res++;
            }
        }

        return res;
    }
};
~~~



## [249. 移位字符串分组](https://leetcode.cn/problems/group-shifted-strings/)

**关键词**：哈希表

~~~c++
class Solution {
public:
    vector<vector<string>> groupStrings(vector<string>& strings) {
        unordered_map<string, int> umap;
        vector<vector<string>> res;

        for(string s : strings){
            bool find = false;
            for(auto it : umap){
                if(snext(s, it.first)){
                    res[it.second].push_back(s);
                    find = true;
                    break;
                }
            }
            if(!find){
                umap[s] = res.size();
                res.push_back(vector<string> {s});
            }
        }

        return res;
    }

    bool snext(string s1, string s2){
        if(s1.size() != s2.size()) return false;
        
        int gap1 = s1[0] - s2[0];
        if(gap1 < 0) gap1+=26;

        for(int i = 1; i<s1.size(); i++){
            if(s1[i] - s2[i] != gap1 && s1[i] - s2[i] + 26!= gap1) return false;
        }

        return true;
    }
};
~~~

