# 海王计划40

[TOC]



## [314. 二叉树的垂直遍历](https://leetcode.cn/problems/binary-tree-vertical-order-traversal/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> verticalOrder(TreeNode* root) {
        vector<vector<int>> res;
        
        if(root == nullptr) return res;
        unordered_map<int, vector<int>> cnt;

        queue<pair<int, TreeNode*>> q;
        q.emplace(0, root);
        int min_value = INT_MAX, max_value = INT_MIN;

        while(!q.empty()){
            auto p = q.front();
            q.pop();
            min_value = min(min_value, p.first);
            max_value = max(max_value, p.first);

            cnt[p.first].push_back(p.second->val);
            if(p.second->left) q.emplace(p.first-1, p.second->left);
            if(p.second->right) q.emplace(p.first+1, p.second->right);
        }

        for(int i = min_value; i<=max_value; i++){
            res.push_back(cnt[i]);
        }

        return res;
    }
};
~~~



## [366. 寻找二叉树的叶子节点](https://leetcode.cn/problems/find-leaves-of-binary-tree/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> findLeaves(TreeNode* root) {
        vector<vector<int>> res;

        dfs(root, res);

        return res;
    }

    int dfs(TreeNode* node, vector<vector<int>>& res){
        if(!node->left && !node->right){
            if(res.size() == 0){
                res.push_back(vector<int>({node->val}));
            }
            else{
                res[0].push_back(node->val);
            }

            return 0;
        }
        
        int numL = 0, numR = 0;

        if(node->left){
            numL = dfs(node->left, res);
        }
        if(node->right){
            numR = dfs(node->right, res);
        }
        int index = 1 + max(numL, numR);

        if(res.size() == index){
            res.push_back(vector<int>({node->val}));
        }
        else{
            res[index].push_back(node->val);
        }
        return index;
    }
};
~~~



## [545. 二叉树的边界](https://leetcode.cn/problems/boundary-of-binary-tree/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> boundaryOfBinaryTree(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        res.push_back(root->val);

        //如果root就是根节点直接返回
        if(!root->left && !root->right) return res;

        LeftBoundary(root->left, res);
        LeafNode(root, res);
        RightBoundary(root->right, res);

        return res;
    }

    void LeftBoundary(TreeNode* node, vector<int>& res){
        if(!node) return;
        //叶节点
        if(!node->left && !node->right) return;

        res.push_back(node->val);
        if(node->left) LeftBoundary(node->left, res);
        else LeftBoundary(node->right, res);
    }

    void LeafNode(TreeNode* node, vector<int>& res){
        if(!node->left && !node->right){
            res.push_back(node->val);
            return;
        }
        if(node->left) LeafNode(node->left, res);
        if(node->right) LeafNode(node->right, res);
        
    }

    void RightBoundary(TreeNode* node, vector<int>& res){
        if(!node) return;
        //叶节点
        if(!node->left && !node->right) return;

        if(node->right) RightBoundary(node->right, res);
        else RightBoundary(node->left, res);
        res.push_back(node->val);
    }

};
~~~

