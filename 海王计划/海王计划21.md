# 海王计划21

[TOC]



## [139. 单词拆分](https://leetcode.cn/problems/word-break/)

**关键词**：一维动态规划

~~~c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet;
        for(auto word : wordDict){
            wordSet.insert(word);
        }

        vector<bool> dp(s.size()+1);
        dp[0] = true;

        for(int i = 0; i <= s.size(); i++){
            for(int j = 0; j<i;j++){
                if(dp[j] && wordSet.find(s.substr(j, i - j)) != wordSet.end()){
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
~~~



## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

**关键词**：一维动态规划

~~~c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
            int Max = amount + 1;
            vector<int> dp(amount+1, Max);
            dp[0] = 0;
            for(int i = 1; i<=amount; i++){
                for(int j = 0; j<coins.size(); j++){
                    if(coins[j] <= i){
                        dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                    }
                }
            }

            return dp[amount] > amount ? -1:dp[amount];
    }
};
~~~



## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

**关键词**：一维动态规划

~~~c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> cnt(nums.size(), 1);

        int res = 1;

        for(int i = 1; i < cnt.size(); i++){
            for(int j = 0; j<i; j++){
                if(nums[j] < nums[i]){
                    cnt[i] = max(cnt[i], cnt[j] + 1);
                }
            }

            res = max(res, cnt[i]);
        }

        return res;
    }
};
~~~

