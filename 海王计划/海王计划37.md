# 海王计划37

[TOC]



## [369. 给单链表加一](https://leetcode.cn/problems/plus-one-linked-list/)

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* plusOne(ListNode* head) {
        ListNode*A = head, *B = head;
        while(B->next){
            if(B->val != 9 && B->next->val == 9){
                A = B;
            }
            else if(B->next->val !=9){
                A = B->next;
            }

            B = B->next;
        }
        ListNode* res = head;
        if(A->val == 9){
            res = new ListNode(1, head);
        }

        A->val = (A->val + 1) % 10;
        A = A->next;
        while(A){
            A->val = 0;
            A = A->next;
        }
        return res;
    }
};
~~~



## [1265. 逆序打印不可变链表](https://leetcode.cn/problems/print-immutable-linked-list-in-reverse/)

~~~c++
/**
 * // This is the ImmutableListNode's API interface.
 * // You should not implement it, or speculate about its implementation.
 * class ImmutableListNode {
 * public:
 *    void printValue(); // print the value of the node.
 *    ImmutableListNode* getNext(); // return the next node.
 * };
 */

class Solution {
public:
    void printLinkedListInReverse(ImmutableListNode* head) {
        vector<ImmutableListNode*> v;
        v.push_back(head);
        ImmutableListNode* temp = head;
        
        while(temp = temp->getNext()){
            v.push_back(temp);
        }

        for(int i = v.size()-1; i>=0; i--){
            v[i]->printValue();
        }
    }
};
~~~



## [1474. 删除链表 M 个节点之后的 N 个节点](https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/)

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNodes(ListNode* head, int m, int n) {
        int cntM = 0, cntN = 0;
        ListNode* cur = head;
        ListNode* valid = head;
        while(cur){
            if(cntM < m){
                valid = cur;
                cur = cur->next;
                cntM++;
                continue;
            }
            else if(cntN < n){
                cur = cur->next;
                valid->next = cur;
                cntN++;
                continue;
            }
            cntM = 0;
            cntN = 0;
        }

        return head;
    }
};
~~~

