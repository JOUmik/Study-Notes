# 海王计划44

[TOC]



## [582. 杀掉进程](https://leetcode.cn/problems/kill-process/)

~~~c++
class Solution {
public:
    vector<int> killProcess(vector<int>& pid, vector<int>& ppid, int kill) {
        unordered_map<int, vector<int>> umap;

        for(int i = 0; i < ppid.size(); i++){
            if(ppid[i] > 0){
                umap[ppid[i]].push_back(pid[i]);
            }
        }

        vector<int> res;

        res.push_back(kill);

        dfs(umap, res, kill);

        return res;
    }

    void dfs(unordered_map<int, vector<int>>& umap, vector<int>& res, int father){
        if(umap.find(father) != umap.end()){
            vector<int> temp = umap[father];

            for(int val : temp){
                res.push_back(val);

                dfs(umap, res, val);
            }
        }
    }
};
~~~



## [323. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/)

~~~c++
class Solution {
public:
    int countComponents(int n, vector<vector<int>>& edges) {
        if(n == 0) return 0;

        int res = 0;

        vector<int> visited(n, 0);
        vector<vector<int>> AttachedNodes(n);

        for(int i = 0; i < edges.size(); i++){
            AttachedNodes[edges[i][0]].push_back(edges[i][1]);
            AttachedNodes[edges[i][1]].push_back(edges[i][0]);
        }

        for(int i = 0; i < n; i++){
            if(visited[i]==0){
                res++;
                dfs(visited, AttachedNodes, i);
            }
        }

        return res;
    }

    void dfs(vector<int>& visited, vector<vector<int>>& AttachedNodes, int index){
        visited[index] = 1;

        vector<int> Attached = AttachedNodes[index];

        for(int i = 0; i<Attached.size(); i++){
            if(visited[Attached[i]] == 0){
                dfs(visited, AttachedNodes, Attached[i]);
            }
        }
    }
};
~~~



## [277. 搜寻名人](https://leetcode.cn/problems/find-the-celebrity/)

~~~c++
/* The knows API is defined for you.
      bool knows(int a, int b); */

class Solution {
public:
    int findCelebrity(int n) {
        for(int i = 0; i < n; i++){
            bool Maybe = false;

            //查找潜在名人
            for(int j = 0; j < n; j++){
                if(j == i) {
                    if(j == n-1) Maybe = true;
                    continue;
                }
                if(knows(i, j)) break;

                if(j == n-1) Maybe = true;
            }

            //判断是否为名人
            if(Maybe){
                for(int j = 0; j<n; j++){
                    if(i == j){
                        if(j == n-1) return i;
                        continue;
                    }
                    if(!knows(j, i)) break;

                    if(j == n-1) return i;
                }
            }
        }

        return -1;
    }
};
~~~

