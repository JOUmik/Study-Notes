# 海王计划15

[TOC]



## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

**关键词**：堆排序

~~~c++
class Solution {
public:
    void max_heapify(vector<int>& arr, int start, int end) {
        //建立父节点指标和子节点指标
        int dad = start;
        int son = dad * 2 + 1;
        while (son <= end) { //若子节点指标在范围内才做比较
            if (son + 1 <= end && arr[son] < arr[son + 1]) //先比较两个子节点大小，选择最大的
                son++;
            if (arr[dad] > arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数
                return;
            else { //否则交换父子内容再继续子节点和孙节点比较
                swap(arr[dad], arr[son]);
                dad = son;
                son = dad * 2 + 1;
            }
        }
    }
    void heap_sort(vector<int>& arr, int len) {
        int i;
        //初始化，i从最后一个父节点开始调整
        for (i = len / 2 - 1; i >= 0; i--)
            max_heapify(arr, i, len - 1);
        //先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕
        for (i = len - 1; i > 0; i--) {
            swap(arr[0], arr[i]);
            max_heapify(arr, 0, i - 1);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        int l = nums.size();
        heap_sort(nums, l);

        return nums[l - k];
    }
};
~~~



## [502. IPO](https://leetcode.cn/problems/ipo/)

**关键词**：优先队列

~~~c++
class Solution {
public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        int n = profits.size();
        int curr = 0;
        priority_queue<int, vector<int>, less<int>> pq;
        vector<pair<int, int>> arr;

        for (int i = 0; i < n; ++i) {
            arr.push_back({capital[i], profits[i]});
        }
        sort(arr.begin(), arr.end());
        for (int i = 0; i < k; ++i) {
            while (curr < n && arr[curr].first <= w) {
                pq.push(arr[curr].second);
                curr++;
            }
            if (!pq.empty()) {
                w += pq.top();
                pq.pop();
            } else {
                break;
            }
        }

        return w;
    }
};
~~~

