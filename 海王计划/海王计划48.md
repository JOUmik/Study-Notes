# 海王计划48

[TOC]



## [1197. 进击的骑士](https://leetcode.cn/problems/minimum-knight-moves/)

**关键词**：BFS

~~~c++
class Solution {
public:
    int minKnightMoves(int x, int y) {
        const vector<vector<int>> DIRECTIONS = {{2,1},{-2,1},{-2,-1},{2,-1},{1,2},{1,-2},{-1,-2},{-1,2}};
        if(x == 0 && y == 0) return 0;
        x = abs(x);
        y = abs(y);
        int res = 0;

        queue<vector<int>> q;
        vector<vector<bool>> visited(310, vector<bool>(310, false));
        visited[0][0] = true;

        q.push({0,0});
        while(!q.empty()){
            int len = q.size();
            for(int i = 0; i<len; i++){
                vector<int> Location = q.front();
                q.pop();
                if(Location[0] == x && Location[1] == y) return res;
                for(auto d:DIRECTIONS){
                    int NewX = Location[0] + d[0], NewY = Location[1] + d[1];
                    if(NewX >= -5 && NewY >= -5 && NewX <= x+5 && NewY <= y+5){
                        if(!visited[NewX+5][NewY+5]){
                            q.push({NewX, NewY});
                            visited[NewX+5][NewY+5] = true;
                        }
                    }
                }
            }

            res++;
        }

        return 0;
    }
};
~~~

