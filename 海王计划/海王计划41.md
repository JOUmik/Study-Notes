## 海王计划41

[TOC]



## [270. 最接近的二叉搜索树值](https://leetcode.cn/problems/closest-binary-search-tree-value/)

**关键词**：二叉搜索树

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int closestValue(TreeNode* root, double target) {
        int res = 0;
        TreeNode* node = root;
        int Max = INT_MAX, Min = INT_MIN;
        while(node){
            if((double) node->val > target){
                Max = min(Max, node->val);
                node = node->left;
            }
            else if((double) node->val < target){
                Min = max(Min, node->val);
                node = node->right;
            }
            else{
                return node->val;
            }
        }

        if((double)Max - target < target - (double)Min){
            return Max;
        }
        else return Min;
    }
};
~~~



## [272. 最接近的二叉搜索树值 II](https://leetcode.cn/problems/closest-binary-search-tree-value-ii/)

**关键词**：优先队列，Lamda表达式，decltype

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> closestKValues(TreeNode* root, double target, int k) {
        vector<int> NumInOrder;
        InorderTraversal(root, NumInOrder);

        vector<int> res;
        
        //Lamda表达式
        auto cmp = [](const pair<int, double>&A, const pair<int, double>&B){
                return A.second > B.second;
        };

        priority_queue<pair<int, double>, vector<pair<int, double>>, decltype(cmp)> pq(cmp);

        for(int i = 0; i<NumInOrder.size(); i++){
            pq.emplace(i, abs(target - NumInOrder[i]));
        }

        for(int i = 0; i < k; i++){
            auto p = pq.top();
            pq.pop();

            res.push_back(NumInOrder[p.first]);
        }

        return res;
    }

    void InorderTraversal(TreeNode* node, vector<int>& NumInOrder){
        if(node->left) InorderTraversal(node->left, NumInOrder);
        NumInOrder.push_back(node->val);
        if(node->right) InorderTraversal(node->right, NumInOrder);
    }
};
~~~



## [255. 验证二叉搜索树的前序遍历序列](https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/)

**关键词**：二叉搜索树

~~~c++
class Solution {
public:
    bool verifyPreorder(vector<int>& preorder) {
        return CheckPreorderTraversal(preorder, 0, preorder.size()-1);
    }

    bool CheckPreorderTraversal(vector<int>& preorder, int begin, int end){
        if(begin >= end) return true;
        int root = preorder[begin];

        bool findUpper = false;
        int UpperBeginIndex = -1;

        for(int i = begin + 1; i <= end; i++){
            if(findUpper){
                if(preorder[i] < root) return false;
            }
            else{
                if(preorder[i] > root){
                    UpperBeginIndex = i;
                    findUpper = true;
                }
            }
        }

        if(UpperBeginIndex != -1){
            if(!CheckPreorderTraversal(preorder, UpperBeginIndex, end)) return false;
            if(!CheckPreorderTraversal(preorder, begin+1, UpperBeginIndex-1)) return false;
        }
        if(UpperBeginIndex == -1){
            if(!CheckPreorderTraversal(preorder, begin+1, end)) return false;
        }

        return true;
    }
};
~~~

