# 海王计划01

并查集介绍：[算法学习笔记(1) : 并查集 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93647900)



## 990. 等式方程的可满足性

**关键词**：不带权重的并查集，无向图

~~~c++
class UnionFind{
private:
    vector<int> fa;   //父节点数组
    vector<int> rank; //深度

public:
    UnionFind(){
        fa.resize(26);
        rank.resize(26);

        //初始化 初始父节点为自己，初始深度为1
        for(int i = 0; i < 26; i++){
            fa[i] = i;   
            rank[i] = 1;
        }
    }

    //查找父节点
    int find(int index){
        return index == fa[index] ? index : fa[index] = find(fa[index]);
    }

    void merge(int i, int j){
        int x = find(i), y = find(j);

        if(rank[x] <= rank[y]){
            fa[y] = x;
        }
        else{
            fa[x] = y;
        }
        if (rank[x] == rank[y] && x != y)
            rank[y]++;   
    }

};

class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        UnionFind uf;
        for (const string& str: equations) {
            if (str[1] == '=') {
                int index1 = str[0] - 'a';
                int index2 = str[3] - 'a';
                uf.merge(index1, index2);
            }
        }
        for (const string& str: equations) {
            if (str[1] == '!') {
                int index1 = str[0] - 'a';
                int index2 = str[3] - 'a';
                if (uf.find(index1) == uf.find(index2)) {
                    return false;
                }
            }
        }
        return true;
        
    }
};
~~~



## 399. 除法求值

**关键词**：带权重的并查集，有向带权图

~~~c++
class UnionFind {
private: 
    vector<int> fa;        //父节点
    vector<int> rank;      //深度
    vector<double> weight; //权重值

public:
    UnionFind(int n){
        fa.resize(n);
        rank.resize(n);
        weight.resize(n);

        for(int i = 0; i < n; i++){
            fa[i] = i;
            rank[i] = 1;
            weight[i] = 1.0;
        }
    }

    int find(int index){
        if(index == fa[index]){
            return index;
        }
        int origin = fa[index];
        fa[index] = find(fa[index]);
        weight[index] *= weight[origin];

        return fa[index];
    }

    void merge(int i, int j, double value){
        int x = find(i), y = find(j);
        if(rank[x] <= rank[y]){
            fa[x] = y;
            weight[x] = weight[j] * value / weight[i];   //该公式由本题设定推导得出
        }
        else{
            fa[y] = x;
            weight[y] = weight[i] / (weight[j] * value); //该公式由本题设定推导得出
        }
        if(rank[x] == rank[y] && x!=y){
            rank[y]++;
        }
    }

    double isConnected(int i, int j){
        int x = find(i), y = find(j);

        if(x == y){
            return weight[i] / weight[j];
        }
        else{
            return -1.0;
        }
    }
};

class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        UnionFind uf(equations.size() * 2);

        vector<double> res;

        //预处理
        int id = 0;

        map<string, int> m;
        map<string, int>::iterator it1, it2;
        for(int i = 0; i<equations.size(); i++){
            vector<string> equation = equations[i];
            string str1 = equation[0];
            string str2 = equation[1];

            it1 = m.find(str1);
            if(it1 == m.end()){
                m[str1] = id;
                it1 = m.find(str1);
                id++;
            }

            it2 = m.find(str2);
            if(it2 == m.end()){
                m[str2] = id;
                it2 = m.find(str2);
                id++;
            }

             uf.merge(it1->second, it2->second, values[i]);
        }

        //查询
        res.resize(queries.size());

        for(int i = 0; i < queries.size(); i++){
            string var1 = queries[i][0];
            string var2 = queries[i][1];

            it1 = m.find(var1);
            it2 = m.find(var2);

            if(it1 == m.end() || it2 == m.end()){
                res[i] = -1.0;
            }
            else{
                res[i] = uf.isConnected(it1->second, it2->second);
            }
        }

        return res;
    }
};
~~~

