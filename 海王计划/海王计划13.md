# 海王计划13

[TOC]

## 33. 搜索旋转排序数组

**关键词**：二分法

~~~c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
      int n = nums.size();
      int l = 0, r = n - 1;

      while(l <= r){
        int mid = (l + r) / 2;
        if(nums[mid] == target) return mid;

        if(nums[l] <= nums[mid]){
          if(nums[l] <= target && nums[mid] > target){
            r = mid - 1;
          }
          else{
            l = mid + 1;
          }
        }
        else{
          if(nums[mid] < target && nums[r] >= target){
            l = mid + 1;
          }
          else{
            r = mid - 1;
          }
        }
      }

      return -1;
    }
};
~~~



## 34. 在排序数组中查找元素的第一个和最后一个位置

**关键词**：二分法

~~~c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int n = nums.size();
        int bl = 0, br = n - 1, el = 0, er = n - 1;
        int begin = -1, end = -1;

        bool find = false;

        while(bl <= br || el <= er){
          if(!find){
            int mid = (bl + br) / 2;
            if(nums[mid] == target){
              br = mid - 1;
              el = mid + 1;
              find = true;
              begin = end = mid;
            }
            else if(nums[mid] > target){
              br = er = mid - 1;
            }
            else{
              bl = el = mid + 1;
            }
          }
          else{
            if(bl <= br){
              int mid = (bl + br) / 2;
              if(nums[mid] == target){
                begin = mid;
                br = mid - 1;
              }
              else if(nums[mid] < target){
                bl = mid + 1;
              }
            }
            if(el <= er){
              int mid = (el + er) / 2;
              if(nums[mid] == target){
                end = mid;
                el = mid + 1;
              }
              else if(nums[mid] > target){
                er = mid - 1;
              }
            }
          }
        }

        return vector<int> {begin, end};
    }
};
~~~

