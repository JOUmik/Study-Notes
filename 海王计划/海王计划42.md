# 海王计划42

[TOC]



## [1214. 查找两棵二叉搜索树之和](https://leetcode.cn/problems/two-sum-bsts/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {
        unordered_map<int, int> umap;
        InorderTraversal(root1, umap);

        return find(root2, target, umap);
    }   

    void InorderTraversal(TreeNode* node, unordered_map<int, int>& umap){
        if(node->left) InorderTraversal(node->left, umap);
        umap[node->val]++;
        if(node->right) InorderTraversal(node->right, umap);
    }

    bool find(TreeNode* node, int& target, unordered_map<int, int>& umap){
        if(!node) return false;
        if(umap.find(target - node->val) != umap.end()) return true;
        else return find(node->left, target, umap) || find(node->right, target, umap);
    }
};
~~~



## [333. 最大 BST 子树](https://leetcode.cn/problems/largest-bst-subtree/)

~~~c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
//Node:l,r表示当前节点为根的二叉搜索树里的值的范围[l,r]，sz为这棵树的节点数，如果不是BST,则sz=-1
struct Node{
    int l,r,sz;
};
class Solution {
    int ans=0;
public:
    Node dfs(TreeNode* root){
        if (root->left==NULL && root->right==NULL){
            ans=max(ans,1);
            return (Node){root->val,root->val,1};
        }
        int sz=1;
        bool valid=1;
        int l=root->val,r=root->val;// 起初的范围是[root->val,root->val]，再根据左右子树更新范围
        if (root->left!=NULL){
            Node L=dfs(root->left);
            if (L.sz!=-1 && root->val>L.r){
                sz+=L.sz;
                l=L.l;
            }
            else valid=0;
        }
        if (root->right!=NULL){
            Node R=dfs(root->right);
            if (R.sz!=-1 && root->val<R.l){
                sz+=R.sz;
                r=R.r;
            }
            else valid=0;
        }
        if (valid){
            ans=max(ans,sz);
            return (Node){l,r,sz};
        }
        // 不是BST，sz设为-1标记不是BST，l,r多少都可以
        return (Node){-1,-1,-1};
    }
    int largestBSTSubtree(TreeNode* root) {
        if (root==NULL) return 0;
        dfs(root);
        return ans;
    }
};
~~~

