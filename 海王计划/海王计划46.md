# 海王计划46

[TOC]



## [305. 岛屿数量 II](https://leetcode.cn/problems/number-of-islands-ii/)

**关键词**：并查集

~~~c++
class Solution {
public:
    vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
        unordered_map<int, int> umap;
        int root = -1;
        vector<int> res;
        res.push_back(1);
        umap[positions[0][0] * 10000 + positions[0][1]] = positions[0][0] * 10000 + positions[0][1];

        for(int i = 1; i < positions.size(); i++){
            root= -1;

            int res_i = res[i-1];
            int index = positions[i][0] * 10000 + positions[i][1];

            //如果之前就是岛，则跳过
            if(umap.find(index) != umap.end()){
                res.push_back(res_i);
                continue;
            }

            res_i++;

            if(positions[i][0] > 0){
                int in = index - 10000;
                ConnectIsland(umap, in, root, res_i);
            }
            if(positions[i][0] < m-1){
                int in = index + 10000;
                ConnectIsland(umap, in, root, res_i);
            }
            if(positions[i][1] > 0){
                int in = index - 1;
                ConnectIsland(umap, in, root, res_i);
            }
             if(positions[i][1] < n-1){
                int in = index + 1;
                ConnectIsland(umap, in, root, res_i);
            }
            

            if(root != -1){
                umap[index] = root;
            }
            else{
                umap[index] = index;
            }
            
            res.push_back(res_i);
        }

        return res;
    }

    int FindRoot(unordered_map<int, int>& umap, int index){
        int val = umap[index];
        //Find Root
        if(val == index) return val;
        else return FindRoot(umap, val);
    }

    void ConnectIsland(unordered_map<int, int>& umap, int& index, int& root, int & res_i){
        if(umap.find(index) != umap.end()){
            int cnt = FindRoot(umap, index);
                if(root != -1){
                    if(root == cnt){
                        //两岛相连无事发生
                    }
                    else{
                        //两岛不相连，将其连接并且减少岛的数量
                        umap[cnt] = root;
                        res_i--;
                    }
                }
                else{
                    root = cnt;
                    res_i--;
                }
            }
    }
};
~~~



## [694. 不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands/)

~~~c++
class Solution {
public:
    int m,n;

    int numDistinctIslands(vector<vector<int>>& grid) {
        int res = 0;
        unordered_set<int> cnt;

        m = grid.size();
        n = grid[0].size();

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    int index = 0;
                    GetIslandIndex(grid, i, j, i, j, index, 0);
                    if(cnt.find(index) == cnt.end()){
                        res++;
                        cnt.emplace(index);
                    }
                    
                }
            }
        }

        return res;
    }

    void GetIslandIndex(vector<vector<int>>& grid, int i, int j, int rooti, int rootj, int& cnt, int Extra){
        grid[i][j] = 2;
        int gap_i = i -rooti, gap_j = j - rootj;

        if(gap_i >0 && gap_j > 0) cnt += (gap_i * 901 + gap_j * 719 + Extra*7) * 1;
        else if(gap_i <= 0 && gap_j <=0) cnt += (gap_i + gap_j * 13 - Extra*37) * 10; 
        else if(gap_i <= 0) cnt += (gap_i * 31 + gap_j * 3 + Extra*5) * 100;
        else if(gap_j <= 0) cnt += (gap_i * 7 - gap_j * 11 - Extra*3) * 1000;

        if(i>0 && grid[i-1][j] == 1) GetIslandIndex(grid, i-1, j, rooti, rootj, cnt, 91);
        if(j>0 && grid[i][j-1] == 1) GetIslandIndex(grid, i, j-1, rooti, rootj, cnt, -3);
        if(i<m-1 && grid[i+1][j] == 1) GetIslandIndex(grid, i+1, j, rooti, rootj, cnt, 17);
        if(j<n-1 && grid[i][j+1] == 1) GetIslandIndex(grid, i, j+1, rooti, rootj, cnt, -741);
    }
};
~~~



## [1136. 并行课程](https://leetcode.cn/problems/parallel-courses/)

**关键词**：拓扑排序

~~~c++
class Solution {
public:
    int minimumSemesters(int n, vector<vector<int>>& relations) {
        //拓扑排序
        //入度
        unordered_map<int, vector<int>> umap_in;
        //出度
        unordered_map<int, int> umap_out;
        for(int i = 0; i<relations.size(); i++){
            umap_out[relations[i][0]]++;
            if(umap_out.find(relations[i][1]) == umap_out.end()) umap_out[relations[i][1]] = 0;

            umap_in[relations[i][1]].push_back(relations[i][0]);
        }

        stack<int> s;
        for(auto it : umap_out){
            if(it.second == 0) s.emplace(it.first);
        }
        int res = 1;
        vector<int> OldClasses;
        while(!s.empty()){
            int classNum = s.top();
            umap_out.erase(classNum);
            s.pop();

            vector<int> PreClasses = umap_in[classNum];
            for(int i = 0; i<PreClasses.size(); i++){
                umap_out[PreClasses[i]]--;
                if(umap_out[PreClasses[i]] == 0){
                    OldClasses.push_back(PreClasses[i]);
                    umap_out.erase(PreClasses[i]);
                }
            }

            if(s.empty() && OldClasses.size() != 0){
                res++;
                for(int i = 0; i<OldClasses.size(); i++) s.emplace(OldClasses[i]);
                OldClasses.clear();
            }
        }

        if(umap_out.empty()) return res;
        else return -1;


    }
};
~~~

