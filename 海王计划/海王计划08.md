# 海王计划08

[TOC]



## 79. 单词搜索

**关键词**：回溯，DFS

~~~c++
class Solution {
public:
    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++){
            for(int j = 0; j < board[0].size(); j++){
                int res = dfs(board, i, j, word, 0);
                if(res > 0) return true;
            }
        }

        return false;
    }

    int dfs(vector<vector<char>>& board, int x, int y, string word, int index){
        if(board[x][y] == word[index]){
            char ch = board[x][y];
            index++;
            if(word.length() == index) return 1;

            board[x][y] = '#';

            int res = 0;

            for(int i = 0; i<4; i++){
                x += dirs[i][0];
                y += dirs[i][1];
                if(x < board.size() && x >= 0 && y < board[0].size() && y >= 0){
                    res += dfs(board, x, y, word, index);
                }

                x -= dirs[i][0];
                y -= dirs[i][1];
            }

            board[x][y] = ch;    //回溯    

            return res;
        }
        else{
            return 0;
        }
    }
};
~~~



## 22. 括号生成

**关键词**：回溯，DFS

~~~c++
class Solution {
public:
    vector<string> res;

    vector<string> generateParenthesis(int n) {
        string s = "";

        dfs(s, n, 0, 0);
        
        return res;
    }

    void dfs(string& s, int n, int l, int r){
        if(l == n && r == n){
            res.push_back(s);
            return;
        }

        if(l < n){
            s += '(';
            dfs(s, n, l+1, r);
            s = s.substr(0, s.length() - 1);
        }
        
        if(l-r > 0){
            s += ')';
            dfs(s, n, l, r+1);
            s = s.substr(0, s.length() - 1);
        }

    }
};
~~~

