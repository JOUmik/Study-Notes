# 海王计划31

[TOC]



## [422. 有效的单词方块](https://leetcode.cn/problems/valid-word-square/)

~~~c++
class Solution {
public:
    bool validWordSquare(vector<string>& words) {
        int n = words.size();
        for(int i = 0; i<n; i++){
            string a = words[i];
            string b = "";

            for(int j = 0; j<n; j++){
                if(words[j].size() > i){
                    b += words[j][i];
                }
            }

            if(a != b) return false;
        }

        return true;
    }
};
~~~



## [531. 孤独像素 I](https://leetcode.cn/problems/lonely-pixel-i/)

~~~c++
class Solution {
public:
    int findLonelyPixel(vector<vector<char>>& picture) {
        vector<bool> hasBlack(picture[0].size(), false);

        int res = 0;
        for(int i = 0; i < picture.size(); i++){
            int index = -1;
            for(int j = 0; j < picture[0].size(); j++){
                if(picture[i][j] == 'B'){
                    if(index == -1 && !hasBlack[j]) index = j;
                    else{
                        index = -2;
                    }
                    hasBlack[j] = true;
                }
            }
            if(index >=0){
                res++;
                for(int j = i+1; j<picture.size(); j++){
                    if(picture[j][index] == 'B'){
                        res--;
                        break;   
                    }
                }
            }
        }

        return res;
    }
};
~~~



## [311. 稀疏矩阵的乘法](https://leetcode.cn/problems/sparse-matrix-multiplication/)

~~~c++
class Solution {
public:
    vector<vector<pair<int, int>>> compressMatrix(vector<vector<int>>& matrix){
        int n = matrix.size(), m = matrix[0].size();

        vector<vector<pair<int, int>>> compressedMatrix(n);

        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(matrix[i][j]!=0) compressedMatrix[i].push_back({matrix[i][j], j});
            }
        }

        return compressedMatrix;
    }

    vector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {
        vector<vector<pair<int, int>>> A = compressMatrix(mat1), B = compressMatrix(mat2);
        int n = mat1.size(), k = mat1[0].size(), m = mat2[0].size();

        vector<vector<int>> res(n, vector<int>(m, 0));
        for(int mat1Row = 0; mat1Row < A.size(); mat1Row++){
            for(auto [mat1Val, mat1Col] : A[mat1Row]){
                for(auto [mat2Val, mat2Col] : B[mat1Col]){
                    res[mat1Row][mat2Col] += mat1Val * mat2Val;
                }
            }
        }

        return res;
    }
};
~~~

