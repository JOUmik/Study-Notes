# 海王计划43

[TOC]



## [1490. 克隆 N 叉树](https://leetcode.cn/problems/clone-n-ary-tree/)

~~~c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    Node* cloneTree(Node* root) {
        if(!root) return nullptr;

        stack<Node*> s1, s2;

        Node* newRoot = new Node(root->val);

        s1.emplace(root);
        s2.emplace(newRoot);
        while(!s2.empty()){
            Node* Old = s1.top();
            s1.pop();
            Node* New = s2.top();
            s2.pop();

            for(int i = 0; i < Old->children.size(); i++){
                Node* temp = new Node(Old->children[i]->val);
                New->children.push_back(temp);
                s1.emplace(Old->children[i]);
                s2.emplace(temp);
            }
        }


        return newRoot;
    }
};
~~~



## [1522. N 叉树的直径](https://leetcode.cn/problems/diameter-of-n-ary-tree/)

~~~c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int diameter(Node* root) {
        int res = 0;
        dfs(root, res);

        return res;
    }

    int dfs(Node* node, int& res){
        int max1 = 0;
        int max2 = 0;
        for(int i = 0; i < node->children.size(); i++){
            int length = 1 + dfs(node->children[i], res);
            if(length >= max1){
                max2 = max1;
                max1 = length;
            }
            else if(length > max2) max2 = length;
        }

        res = max(res, max1 + max2);

        return max1;
    }
};
~~~



## [1506. 找到 N 叉树的根节点](https://leetcode.cn/problems/find-root-of-n-ary-tree/)

~~~c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    Node* findRoot(vector<Node*> tree) {
        int valueSum = 0;

        for(Node* i : tree){
            valueSum += i->val;
            for(Node* j : i->children){
                valueSum -= j->val;
            }
        }

        Node* res;

        for(Node* i : tree){
            if(i->val == valueSum){
                res = i;
                break;
            }
        }

        return res;
    }
};
~~~

