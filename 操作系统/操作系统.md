# 操作系统

[TOC]



## 1. 为什么需要操作系统

- 操作系统类似于一个协调者，它提供了一套接口和标准来抹平不同硬件的差异，这样只要操作系统一样，硬件能达到软件运行的最低标准，那么软件就可以运行，不需要考虑硬件的差异
- 同时，操作系统为所有程序分配资源，一切程序都要听从操作系统的调度，当它们需要访问资源时需要向操作系统申请权限由操作系统进行资源的分配，这样可以最大程序利用计算机资源的同时让各个程序互不冲突
- 操作系统屏蔽了底层硬件调度的细节，为应用程序提供基础，担当计算机用户和计算机硬件的中介，减少开发人员的开发难度，让非技术人员也能使用计算机系统
- 操作系统提供了便利，高效的使用体验



## 2. System/Application Programs

操作系统包含系统或应用程序

- 系统程序：

系统程序是用于直接命令或修改计算机硬件的软件

- 应用程序：

应用程序是用于执行特定任务，可供用户直接使用的程序或软件（比如office， 编译器，网页浏览器等）



## 3. 引导程序（Bootstrap Program）

电脑启动或重新运行时执行的第一个程序。引导程序存储于ROM(Read Only Memory)中，它必须知道如何加载操作系统并开始执行系统，它必须定位操作系统内核并将其加载到内存中



## 4. 中断（Interrupt）

- **来源**：中断通常来源于硬件设备，如I/O操作完成、定时器溢出等。也可以由软件生成，称为软中断或软件中断。
- **异步性**：中断是异步发生的，与CPU的当前执行流程无关。
- **目的**：中断的主要目的是响应外部事件或内部事件，允许操作系统对这些事件进行处理，如处理硬件请求、执行定时任务等。
- **处理**：中断会导致当前执行流程被打断，操作系统保存当前的上下文（程序计数器、寄存器等），转而执行与中断对应的中断服务例程（ISR）。ISR执行完毕后，系统恢复被中断的任务。



一个事件的发生通常由从硬件或软件的中断发出信号，在CPU做某项工作时，有时硬件或软件可能会中断CPU正在执行的工作，并让它执行另一个工作，执行完成后回到当前工作继续执行，硬件通常使用系统总线向CPU发送信号来触发中断



中断处理通常涉及以下步骤：

1. **中断触发**：硬件设备向处理器发送中断信号。
2. **中断响应**：当前执行被暂停，处理器保存当前的上下文（如程序计数器、寄存器等）。
3. **执行中断服务例程（ISR）**：根据中断向量表找到对应的中断服务例程并执行。中断向量表是一个函数指针数组，每个元素指向一个ISR。
4. **中断返回**：ISR执行完成后，处理器恢复之前保存的上下文，并继续执行被中断的任务。

### 4.1 系统调用

软件可以通过执行称为系统调用的特殊操作来触发中断



### 4.2 CPU响应

当CPU被中断时会停止执行当前任务并立即将执行转移到固定位置（通常是中断服务程序的起始地址），每一个中断都有一个中断服务程序，当CPU执行完中断服务程序后会回到之前执行的任务继续执行



## 5. 异常

异常是由程序执行中的非法操作或错误条件引起的同步事件。异常通常表示某种错误情况，需要由操作系统或程序的异常处理部分处理。根据其性质和严重性，异常可以分为两大类：

- **故障（Fault）**：表明操作由于某种可恢复的错误而失败。处理完故障后，程序可能能够继续执行。例如，页面故障（缺页异常）是一种典型的故障，操作系统通过从磁盘加载缺失的页面到内存来处理这种故障。
- **陷阱（Trap）和中止（Abort）**：陷阱通常是由程序主动引起的，用于调试等目的，而中止通常是严重错误导致的，可能无法恢复，如非法指令、除零错误等。



- **同步性**：异常是同步发生的，它们是由程序执行的特定指令直接触发的。
- **目的**：异常处理的主要目的是响应程序中的错误情况。操作系统或应用程序可以通过异常处理机制来决定如何应对这些错误，比如恢复操作、重试、终止程序或其他错误恢复手段。
- **处理**：当异常发生时，程序的正常执行流程被中断，操作系统将控制权转移给异常处理程序。根据异常的类型和严重性，处理程序可以采取不同的措施，处理完成后可能返回到触发异常的点继续执行，也可能不返回。



## 5. 进程

被加载到内存中执行的程序被称为“进程”

### 5.1 进程状态

- #### 新建（New）

​	这是进程刚被创建时的状态。在这个状态下，操作系统为进程分配了必要的资源，例如内存空间、进程控制块（PCB）等。一旦分配完成，进程就可以转移到就绪状态。

- #### 就绪（Ready）

​	进程已准备好运行，并等待CPU时间。在这个状态下，进程已经拥有除CPU之外的所有必要资源，它被放在就绪队列中，等待操作系统的调度程序（Scheduler）将其选中并分配CPU时间片，以便执行。

- #### 运行（Running）

​	进程正在CPU上执行。一个进程在任意时刻只能在一个CPU上运行。当进程获得CPU时间后，它可以执行指令、进行计算等。运行状态的进程可能由于时间片用完、等待I/O操作或其他资源而转换到其他状态。

- #### 等待（Waiting 或 Blocked）

​	进程因为等待某种条件（如I/O操作完成、获取某种锁资源等）而暂停执行。在这个状态下，即使CPU空闲，进程也无法执行，直到其等待的条件得到满足。满足条件后，进程通常会转移到就绪状态，等待重新获得CPU时间。

- #### 终止（Terminated 或 Exit）

​	进程完成执行或者被操作系统终止。在这个状态下，进程的所有资源，包括打开的文件、占用的内存等，都会被操作系统回收。进程的PCB会保留一些终止信息直到操作系统处理完毕，之后也会被删除。

****

- #### 进程状态转换

进程在其生命周期中会经历多种状态，状态之间的转换通常由操作系统事件（如时间片用尽、I/O请求完成等）触发。这些状态转换反映了进程对系统资源的需求以及操作系统对资源的调度策略。

- #### 可选状态

除了上述基本状态外，一些系统可能还支持其他进程状态，例如：

**挂起就绪（Suspended Ready）**：进程已经准备好运行，但被移到外部存储，这通常发生在系统需要为其他进程释放内存时。

**挂起等待（Suspended Blocked）**：进程因等待某些条件而被挂起，通常是因为系统资源紧张。



### 5.2 PCB(Process Control Block)

每个进程在操作系统中都由一个进程控制块表示，简称PCB

- ### **`PCB主要包含以下信息：`**

1. **进程标识符（PID）**：每个进程的唯一标识。系统可以通过PID来区分不同的进程。
2. **进程状态**：进程当前的状态，如就绪（Ready）、运行（Running）、等待（Waiting）或终止（Terminated）等。
3. **程序计数器（PC）**：指向进程将要执行的**下一条指令的地址**。程序计数器使得操作系统能够在进程被中断后恢复执行。
4. **CPU寄存器信息**：保存进程执行状态的寄存器集，包括累加器、索引寄存器、栈指针等。当进程被中断时，其寄存器状态会被保存到PCB中，以便进程恢复执行时能够恢复这些值。
5. **CPU调度信息**：包括进程优先级、调度队列指针、调度参数等，这些信息用于进程调度决策。
6. **内存管理信息**：包括进程的地址空间信息，如页表、段表等，用于虚拟内存管理和物理地址映射。
7. **账户信息**：记录进程使用的CPU时间、实际使用时间等，用于统计、限制和计费等。
8. **I/O状态信息**：包括分配给进程的I/O设备列表、打开文件的列表等。这些信息用于管理进程的输入输出操作。

- ### `PCB的作用`

- **进程管理**：PCB是操作系统管理进程生命周期的基础。通过PCB，操作系统能够创建、调度、中断和终止进程。
- **进程切换**：在进行进程切换时，操作系统会保存当前进程的状态到其PCB中，并从另一个进程的PCB中恢复其状态，以实现多任务。
- **资源管理**：PCB帮助操作系统跟踪每个进程使用的资源，如内存、文件和I/O设备，确保资源正确分配和回收。
- **同步与通信**：PCB中的信息可以用于进程同步和通信机制，如信号量、消息队列等。



### 5.3 进程调度算法

- #### 先来先服务（FCFS, First-Come, First-Served）

**非抢占式**

这是最简单的调度算法。进程按照它们到达就绪队列的顺序被调度。一旦一个进程开始执行，它会持续运行，直到完成。FCFS的主要问题是平均等待时间可能很长，特别是当长进程运行在短进程之前时。

- #### 短作业优先（SJF, Shortest Job First）

**非抢占式**

在这个算法中，具有最短执行时间的进程首先获得CPU。这种非抢占式调度可以最小化平均等待时间。然而，它的主要问题是饥饿（长作业可能永远得不到调度），以及需要提前知道进程的执行时间。

- #### 最短剩余时间优先（SRTF, Shortest Remaining Time First）

**抢占式**

这是SJF的抢占式版本。如果一个新进程到达就绪队列，其预计执行时间小于当前运行进程的剩余时间，调度器会中断当前进程并将CPU分配给新进程。这种方法减少了等待时间，但也增加了上下文切换的次数。

- #### 时间片轮转（RR, Round Robin）

**抢占式**

RR调度算法将CPU时间分成固定长度的片段，称为时间片，然后将它们分配给就绪队列中的每个进程。每个进程运行一个时间片的长度。如果进程在时间片结束时尚未完成，它会被放回就绪队列的末尾。这种方法提高了响应性，但较短的时间片会导致较高的上下文切换开销。

- #### 优先级调度

在优先级调度算法中，每个进程都有一个优先级，调度器根据这些优先级分配CPU时间。具有最高优先级的进程首先获得CPU。**优先级调度可以是非抢占式的或抢占式的**（即一个更高优先级的进程到来时，可以中断当前进程）。这种方法的问题在于较低优先级的进程可能遭受**饥饿**。

- #### 多级反馈队列（MFQ, Multilevel Feedback Queue）

多级反馈队列是一种复杂的调度算法，它设有多个就绪队列，每个队列具有不同的优先级。进程根据其属性（如CPU使用时间、进程优先级等）被分配到不同的队列中。调度器首先考虑最高优先级的队列。MFQ旨在提供良好的响应时间，同时考虑到CPU利用率和吞吐量，但它的实现相对复杂。



### 5.4 上下文切换

进程的上下文切换是指操作系统在切换从一个进程到另一个进程执行时所进行的一系列操作。这个过程涉及保存当前进程的状态（上下文）并恢复另一个进程的状态，以便新的进程可以从它上次停止的地方继续执行。

- #### `上下文的内容`

进程的上下文主要包括：

- **CPU寄存器状态**：包括通用寄存器、程序计数器（PC）、栈指针（SP）和状态寄存器等。
- **程序计数器**：指向进程将要执行的下一条指令的内存地址。
- **进程状态信息**：如进程的优先级、调度状态和进程ID等。
- **内存管理信息**：如页表、内存分配的状态等。
- **开放文件和I/O状态信息**：如文件描述符、I/O缓冲区等。

- #### `上下文切换的触发`

上下文切换可能由以下几种原因触发：

- **时间片用尽**：在基于时间片的调度算法中，当当前进程的时间片用尽时，操作系统会触发上下文切换。
- **I/O请求**：当进程进行I/O操作而被阻塞时，操作系统会切换到另一个进程。
- **高优先级进程就绪**：当一个高优先级的进程变为就绪状态时，操作系统可能会抢占当前运行的进程，进行上下文切换。
- **等待系统资源**：如信号量、互斥锁等。

- #### `上下文切换的过程`

1. **中断或系统调用**：上下文切换首先由系统调用、中断或异常触发。
2. **保存当前进程上下文**：操作系统保存当前进程的CPU寄存器和其他关键状态到其进程控制块（PCB）。
3. **选择新的进程**：调度器选择另一个进程执行。
4. **恢复新进程上下文**：操作系统从新选定的进程的PCB中恢复CPU寄存器和其他关键状态。
5. **执行新进程**：新的进程开始执行。

- #### `上下文切换的代价`

上下文切换是有代价的，包括：

- **时间开销**：保存和恢复进程状态需要时间，**这期间CPU不做任何有用的工作**。
- **缓存冷却**：新的进程可能会有不同的内存访问模式，导致CPU缓存的数据被替换，从而降低缓存的命中率。

- #### `优化上下文切换`

- **减少不必要的上下文切换**：通过优化调度策略，减少不必要的上下文切换。
- **使用线程**：线程间的上下文切换代价通常低于进程间的切换，因为线程共享同一地址空间和资源。



### 5.5 子进程

- #### `子进程的创建`

子进程通常通过特定的系统调用创建，如UNIX和Linux中的`fork()`，Windows中的`CreateProcess()`等。这些调用创建一个新的进程，该进程几乎是父进程的副本：

- **UNIX/Linux的`fork()`**：`fork()`调用创建一个新进程，该进程是调用进程的副本。新进程（子进程）从`fork()`调用之后的点开始执行，拥有与父进程几乎相同的内存映像，但有其自己的地址空间。
- **执行新程序**：子进程通常会使用如`exec()`系列函数（在UNIX/Linux中）来执行一个新的程序。`exec()`函数替换当前进程的内存空间，包括代码和数据，用新程序的代码和数据。

****

- #### `子进程的特性`

- **独立执行**：子进程拥有独立的地址空间，父进程和子进程的运行互不干扰。子进程的任何数据修改都不会影响父进程，反之亦然。
- **资源共享**：虽然子进程拥有独立的地址空间，但在某些操作系统中，子进程在创建时会继承父进程的资源，如打开的文件描述符（UNIX/Linux）。
- **通信**：子进程可以通过管道、信号、共享内存、消息队列等机制与父进程或其他进程通信。
- **同步**：父进程可以通过特定的系统调用（如`wait()`）等待子进程结束，这在父进程需要子进程完成某些任务后再继续执行时非常有用。

****

- #### `子进程的用途`

- **并行处理**：子进程可以用来并行执行多个任务，提高应用程序的性能。
- **简化编程模型**：通过将复杂任务分解为多个简单的子任务，并为每个子任务创建一个子进程，可以简化编程模型。
- **隔离**：子进程提供了一种隔离机制，使得不同任务在不同的进程空间中运行，增加了系统的稳定性和安全性。

****

- #### `注意事项`

- **资源管理**：大量使用子进程可能会导致资源（如内存和处理器）的过度使用，因此需要谨慎管理。
- **僵尸进程**：如果父进程没有通过`wait()`（或相关函数）等待子进程结束，子进程在结束时可能会成为僵尸进程，占用系统资源。
- **孤儿进程**：如果父进程在子进程之前结束，子进程将成为孤儿进程。在大多数系统中，孤儿进程会被init进程（或类似的进程）接管。

子进程是操作系统进程管理和并发编程中的一个重要概念，通过合理使用子进程，可以设计出高效、模块化和易于管理的应用程序。



### 5.6 僵尸进程

僵尸进程是已经完成执行但仍然在操作系统进程表中占据一个条目的进程。这种情况发生在子进程已经结束，但其父进程尚未通过调用`wait()`或`waitpid()`系统调用来回收子进程的状态信息时。僵尸进程不执行任何代码，也不消耗除了进程表条目之外的任何资源，但它们会占用有限的系统资源——进程号（PID），因此系统上不能有无限多的僵尸进程。

****

- ### 僵尸进程的产生

****

当子进程结束执行时，它会释放占用的大部分资源（如内存和打开的文件），但在操作系统的进程表中仍然保留一个条目，该条目包含了**进程的退出状态及其他一些终止信息**。操作系统保留这些信息是为了让父进程在稍后能够查询子进程的终止状态。如果父进程没有调用`wait()`或`waitpid()`来查询这些信息，子进程的进程表条目就不会被释放，从而导致僵尸进程的出现。



****

- ### 僵尸进程的问题

****

虽然单个僵尸进程消耗的资源非常少，但它们会占用进程号。在UNIX和Linux系统中，进程号是有限的，如果大量僵尸进程累积，可能会耗尽可用的进程号，导致系统无法启动新的进程。



****

- ### 如何处理僵尸进程

****

1. **父进程调用`wait()`或`waitpid()`**：这是预防和处理僵尸进程的最直接方法。这些系统调用使父进程暂停执行，直到它的一个或多个子进程结束，然后回收子进程的状态信息，释放进程表条目。
2. **使用信号**：父进程可以为`SIGCHLD`信号安装一个处理函数，该信号在子进程结束时由操作系统发送给父进程。在信号处理函数中，父进程可以调用`wait()`来回收子进程的状态信息。
3. **父进程结束**：如果僵尸进程的父进程结束，所有剩余的僵尸子进程将被init进程（**PID为1的进程**）领养，**init进程会定期调用`wait()`来回收任何僵尸进程的状态信息**。
4. **避免创建子进程**：在某些情况下，可以通过使用其他并发编程模型（如线程）来避免创建子进程，从而避免僵尸进程的问题。



### 5.7 孤儿进程

孤儿进程是指父进程结束或终止之后仍在运行的子进程。在父进程终止后，没有被终止的子进程将被init进程（在UNIX和Linux系统中，其进程ID通常为1）接管。init进程会定期执行`wait()`系统调用来回收孤儿进程的状态信息，从而防止孤儿进程成为僵尸进程。

****

- ### 孤儿进程的产生

****

- 当一个进程终止时，它的所有子进程将由init进程领养，这些子进程因此成为孤儿进程。这通常发生在父进程因为某种原因提前结束，而子进程还在后台运行时。
- 如果一个子进程是由一个已经终止的父进程创建的，但这个子进程还没有结束，那么这个子进程就变成了孤儿进程。

****

- ### 孤儿进程的处理

****

- 在UNIX和Linux系统中，init进程负责领养孤儿进程。init进程会定期执行`wait()`系统调用来等待孤儿进程结束，并回收它们的资源和状态信息。这样做是为了确保没有进程能永远处于未回收的状态，防止资源泄露。
- 孤儿进程通常不会对系统性能产生负面影响，因为它们仍然可以像正常进程一样运行。一旦它们结束执行，init进程将回收它们所占用的资源。

****

- ### 孤儿进程与僵尸进程的区别

****

- 孤儿进程和僵尸进程都是在特定条件下出现的进程状态，但它们之间有本质的区别。孤儿进程是已经失去父进程的子进程，但它仍然在运行并消耗资源；而僵尸进程是已经结束但其状态信息还未被父进程回收的进程，它不执行任何操作，不消耗除了进程表项之外的任何资源。
- 孤儿进程会被init进程领养，并在执行完成后由init进程清理；僵尸进程则需要其原父进程（或在某些系统中可能是init进程）通过调用`wait()`或`waitpid()`来回收其资源。



### 5.8 进程间通信





## 6. 线程

线程是进程内的执行单元，一个进程可以有多个线程，线程还是CPU调度的最小单元 

### 6.1 线程状态

线程也有**类似于进程的状态**，这些状态描述了线程在其生命周期中的不同阶段。线程作为轻量级的执行单元，共享进程的资源如代码段，内存和文件句柄，但它们拥有自己的执行上下文，包括**程序计数器、寄存器集和栈**。线程的状态管理对于多线程程序的性能和资源利用至关重要。

1. **新建（New）**：线程已经被创建，但尚未开始执行。在这个状态下，线程的资源和执行上下文已经准备好，等待被线程调度器选中分配CPU时间。
2. **就绪（Runnable/Ready）**：线程准备好执行，等待获取CPU时间。就绪状态的线程位于线程调度器的就绪队列中，一旦调度器选择了某个线程，它就会转移到运行状态。
3. **运行（Running）**：线程正在CPU上执行。线程从就绪状态转移到运行状态后，会执行其任务直到完成，或者因某些原因被迫暂停。
4. **阻塞（Blocked）/等待（Waiting）**：线程由于某些原因无法继续执行，进入等待状态，直到某个事件发生。这可能是因为I/O操作、获取同步锁失败或其他等待资源。阻塞状态的线程不会消耗CPU资源，它们在等待事件完成后会转移到就绪状态。
5. **超时等待（Timed Waiting）**：允许线程在指定的时间内等待某个条件的发生。如果条件在超时时间内得到满足，线程会继续执行；如果超时时间到达而条件仍未满足，线程可以选择继续等待、重试或执行其他操作。这种机制对于避免线程永久阻塞在某个条件上非常有用，特别是在条件可能因为外部因素而长时间不满足的情况下。
6. **终止（Terminated）**：线程的执行已经完成或者被强制终止。一旦线程终止，它所占用的所有资源将被释放，线程对象变为不可再用。