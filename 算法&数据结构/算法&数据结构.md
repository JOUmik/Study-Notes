# 算法&数据结构

[TOC]

## 1. 数据结构

### 1.1 堆

#### 1.1.1 堆的定义

**（这里指的是数据结构里的堆，不是操作系统的堆，二者不一样注意区分）**

堆一般都使用**完全二叉树**，完全二叉树有这些性质：

- 完全二叉树**只允许最后一行不为满**
- 最后一行必须从左到右排序
- 最后一行元素之间不可以有间隔

同时，堆还有自己独有的重要性质——**堆序性**：父节点要比左右子节点数值大（小），即大根堆（小根堆）

<img src="Images\image-20240404070238416.png" alt="image-20240404070238416" style="zoom:50%;" />



#### 1.1.2 堆的储存

基于完全二叉树的性质，堆可以使用一个**一维数组**来存储，如下图所示：

![image-20240404070640427](Images\image-20240404070640427.png)

节点间**规律**如下：

- 节点下标为 $i$;
- 左子节点下标为 $2i+1$;
- 右子节点下标为 $2i+2$​;



#### 1.1.3 堆的基本操作（上滤，下滤）

（以下说明**以大根堆为例子**，小根堆同理）

**下滤**  复杂度$O(logN)$

​	当父节点的值小于子节点时不满足大根堆的性质，此时需要调整该节点的位置，这个操作称为下滤，具体操作如下：

- 对比左右子节点找到最大的节点，将需要调整的节点与该节点进行交换，这一步的目的是保证调整后的父节点一定比子节点大
- 当调整后仍不满足大根堆的性质时，继续调整，直到满足大根堆性质或该节点已经是叶子节点



**上滤**  复杂度$O(logN)$

​	**上滤的操作主要用于新元素插入到堆中时**，当树的最后一个节点破坏了堆序性，即该节点大于父节点时需要进行上滤操作，具体操作如下：

- 将该节点与父节点进行比较，如果大于父节点则和父节点进行交换
- 当调整后仍不满足大根堆的性质时，继续调整，直到满足大根堆性质或该节点已经是根节点



#### 1.1.4 堆的应用（优先队列）

优先队列有**两种操作**，一个是**插入元素**，另一个是**弹出**最大元素（大根堆）或最小元素（小根堆）

**插入元素：**复杂度$O(logN)$

​	将元素插入堆的末尾，执行**上滤操作**即可



**弹出：**

​	将根节点弹出并将堆的**最后一个元素移动到根节点**，执行**下滤操作**



#### 1.1.5 堆的应用（堆排序）

​	简单来讲就是构建大根堆（小根堆）后将元素依次弹出，此时元素一定是有序的，具体请跳转**2.2.7**查看



## 2. 算法

### 2.1 B树

问：为什么要保证m阶B树非根节点的关键字的数量要大于等于$ceil(m/2)-1$?

因为B树某个节点的分裂条件是关键字的数量大于m-1也就是等于m的时候，这时候会从中间分为两个节点，两个节点关键字的数量是ceil(m/2)-1,ceil(m/2)-1或者ceil(m/2), ceil(m/2)+1，基于这样一个原因必须保证删除后关键字的数量要大于等于$ceil(m/2)-1$，不然就破坏了B树的特性



### 2.2 排序算法

[十大经典排序算法 - 冰狼爱魔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/itsharehome/p/11058010.html)

#### 2.2.1 选择排序

性质：1、时间复杂度：$O(n^2)$  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序

不断找未排序区最小的元素，将其与未排序区第一个进行交换，同时减小未排序区的范围



#### 2.2.2 插入排序

性质：1、时间复杂度：$O(n^2)$  2、空间复杂度：O(1)  3、稳定排序  4、原地排序

假设第一个元素已经排好序，不断选取未排序区的元素将其插入到已排序区的对应位置，使其大于前一个小于后一个

初始数据有序程度越高或数据集越小，越高效（移动少）

#### 2.2.3 冒泡排序

性质：1、时间复杂度：$O(n^2)$  2、空间复杂度：O(1)  3、稳定排序  4、原地排序

适用于查找最大（小）的第n个元素

将第一个与第二个比较，如果大于第二个则交换位置，不断交换，最终排在最右边的一定就是未排序区最大的元素

- **优化：**

当遍历一次后没有发生交换则说明已经排好可以直接返回



#### 2.2.4 希尔排序

性质：1、时间复杂度：$O(NlogN)$  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序

希尔排序是对插入排序的一种优化，用来减少移动次数，先让间隔为n/2的元素彼此有序，再让n/4的元素彼此有序，每排一次，数组都会比之前更加有序一些，这样当最后要进行将间隔为1的元素之间彼此有序的操作时（同插入排序），要移动的元素就会少很多



#### 2.2.5 归并排序

性质：1、时间复杂度：$O(NlogN)$  2、空间复杂度：O(n)  3、稳定排序  4、非原地排序

归并（递归，合并），基于分治思想的排序。通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。



不考虑递归所消耗的空间，空间复杂度为O(1)的方法：[「归并排序：题目一」如何实现一个空间复杂度为 O(1) 的归并排序？-CSDN博客](https://blog.csdn.net/been123456789jimmy/article/details/107308695)



#### 2.2.6 快速排序

性质：1、时间复杂度：$O(NlogN)$  2、空间复杂度：O(logn)  3、非稳定排序  4、原地排序

[【漫画】不要再问我快速排序了 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkxODI3NDk5Nw==&mid=2247498438&idx=1&sn=23917e1f0a446f609057b67c741f0024&source=41#wechat_redirect)

和归并排序一样采用了分治的思想，但是它不需要额外的数组，也不需要把额外的数组内容复制到原数组，但是因为它用到了递归，而递归本身要保存数据所以占用一定空间导致空间复杂度为O(logn) ，

每次取一个主元调整它的位置，使其左边的小于等于它，右边的大于等于它



#### 2.2.7 堆排序

[【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.337.search-card.all.click&vd_source=53a77c8f3400e4ce7b1a48f61c2c3fce)

性质：1. 时间复杂度：$O(NlogN)$   2、空间复杂度：O(1)  3、非稳定排序  4、原地排序



堆排序的整体过程是先将要排序的数组构造成大根堆（小根堆），再弹出根节点，但是要注意的是和优先队列的弹出不同，假设数组分为**未排序部分**和**已排序部分**，弹出的根节点时会把未排序部分的最后一个节点放入根节点并**把根节点放入最后一个节点的位置**，减少未排序部位的长度继续弹出，直到所有的都弹出此时就是一个有序的数组了，因为弹出的数会放在数组的后半部分，所以**使用大根堆排序的结果是正序的，使用小根堆排序的结果是倒序的**



#### 2.2.8 计数排序

性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(k)  3、稳定排序  4、非原地排序

适合于最大值和最小值的差值不是不是很大的排序

**基本思想：**就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。



#### 2.2.9 桶排序



#### 2.2.10 基数排序



#### 2.2.11 总结

![image-20240404080759795](Images\image-20240404080759795.png)