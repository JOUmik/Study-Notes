# 计算机网络

[TOC]

## 1. 简述

## 2. 物理层

## 3. 数据链路层

## 4. 网络层

## 5. 运输层

### 5.1 概述

​	计算机网络体系结构中的**物理层、数据链路层以及网络层**它们共同解决了将主机通过异构网络互联起来所面临的问题，**实现了主机到主机的通信**。

​	但实际上在计算机中进行**通信的真正实体是位于通信两端主机中的进程**。

​	**如何为运行在不同主机上的应用进程（AP）提供直接的通信服务是运输层的任务**，运输层协议又称为端到端协议

![image-20240330213528226](Images\image-20240330213528226.png)

​	假设AP1和AP4之间，AP2和AP3之间进行基于网络的通信，在运输层使用**不同的端口**对于不同的应用进程，通过网络层及其下层来传输应用层报文，接收方的运输层**通过不同的端口将收到的应用层报文交付给应用层中相应的应用进程**。需要注意的是，这里的**端口是指用来区分不同应用进程的标识符**，可以简单的认为**运输层直接为应用进程间的逻辑通信提供服务**

**逻辑通信：**运输层之间的通信好像是沿水平方向传送数据，但事实上两条运输层之间并没有一条水平方向的物理连接，**运输层向高层用户屏蔽了网络核心的细节**（如网络拓扑，所采用的路由选择协议等）。

​	根据应用需求的不同，**因特网的运输层**为应用层提供了两种不同的运输协议，即**面向连接的TCP**和**无连接的UDP**，这两种协议就是本章讨论的主要内容。

![image-20240330220146188](Images\image-20240330220146188.png)

### 5.2 端口号，复用与分用

#### 5.2.1 端口号

**定义：**

​	与本地进程通信（IPC）使用进程标识符PID来标识不同进程不同，远程进程通信（RPC）使用**端口号来标识不同的进程。** 这是因为因特网上的计算机使用的并不是统一的操作系统，**不同的操作系统有不同格式的PID**，为了使这些使用不同操作系统的计算机的应用进程能进行通信就**必须定义一个统一的格式对TCP/IP体系的应用程序进行标识**，这就是端口号存在的意义



**端口号使用16比特表示，取值范围0~65535：**

- **熟知端口号：** **0~1023**，互联网数字分配机构（IANA）把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如:FTP使用21/20，HTTP使用80，DNS使用53；
- **登记端口号：**1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定
  的手续登记，以防止重复。例如:Microsoft RDP 微软远程桌面使用的端口是3389；
- **短暂端口号：**49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的**动态端口号**。通信结束后，这个端口号可供其他客户进程以后使用；

​	**端口号只具有本地意义**，即端口号只是为了**标识本计算机应用层中的各进程**，在因特网中**不同计算机中的相同端口号是没有联系的**



#### 5.2.2 发送方的复用和接收方的分用

***复用：与发送方有关***

- **UDP复用：** **发送方**发送的应用报文在运输层使用UDP协议进行封装，这称为UDP复用；
- **TCP复用：** **发送方**发送的应用报文在运输层使用TCP协议进行封装，这称为TCP复用；
- **IP复用：**运输层使用端口号来区分不同的应用进程，不管**发送方**使用运输层的UDP协议封装成的**UDP用户数据报**，还是使用TCP协议封装成的**TCP报文段**，在**网络层**都需要**使用IP协议封装成IP数据报**，这称为IP复用。根据**协议字段的不同来区分**封装的是UDP数据报（17）还是TCP报文段（6）；



***分用：与接收方有关***

**IP分用：** **接收方**的**网络层**收到IP数据报后进行IP分用，若IP数据报协议字段值为17则把IP数据报的数据载荷部分封装的UDP用户数据报**上交给运输层的UDP**，若值为6则把IP数据报的数据载荷部分封装的TCP报文段上交给**运输层的TCP；**

**UDP分用：** **接收方**对UDP用户数据报进行UDP分用，根据端口号交付给对应的应用进程；

**TCP分用：** **接收方**对TCP报文报进行TCP分用，根据端口号交付给对应的应用进程；

![image-20240330222951053](Images\image-20240330222951053.png)

****

***TCP/IP体系应用层常用协议所使用的运输层熟知端口号***

![image-20240330223139728](Images\image-20240330223139728.png)



### 5.3 UDP和TCP的对比

**UDP**和**TCP**是TCP/IP体系结构**运输层**中的**两个重要协议**，在使用TCP/IP体系结构的网络通信中，UDP和TCP的使用协议仅次于网络层的IP协议

| 用户数据报协议UDP                          | 传输控制协议TCP                                   |
| ------------------------------------------ | ------------------------------------------------- |
| 无连接                                     | 面向连接                                          |
| 支持一对一，一对多，多对一和多对多交互通信 | 每一条TCP连接只能有两个端点，**只能是一对一通信** |
| 对应用层交付的报文直接打包                 | 面向字节流                                        |
| 尽最大努力交付，也就是**不可靠**           | **可靠传输**                                      |
| 不使用流量控制和拥塞控制                   | **使用流量控制和拥塞控制**                        |
| 首部开销小，仅8字节                        | 首部最小20字节，最大60字节                        |

****

***连接的不同*：**

![image-20240331194151250](Images\image-20240331194151250.png)

****

***通信的不同*：**

**UDP：**使用UDP协议进行通信的四台主机，其中任何一台主机都可向其他三台主机发送广播，也可向某个**多播组**发送组播（多播），还可以向某台主机发送单播，也就是说，UDP**支持一对一，一对多以及一对全的通信**

**TCP：**使用TCP协议的通信双方在进行数据传输之前必须使用“三报文握手”建立TCP连接，建立成功后，通信双方之间就**好像有一条可靠的通信信道**，通信双方使用这条基于TCP连接的可靠信道进行通信，因此**TCP仅支持单播，也就是一对一的通信**

![image-20240331195120763](Images\image-20240331195120763.png)

****

***应用报文的处理：***

**UDP：** 

​	**发送方**的应用进程将应用层报文交付给运输层的UDP，UDP直接给应用层报文添加一个UDP首部使之成为**UDP用户数据报**然后进行发送。**接收方**收到该UDP用户数据报后去掉UDP首部，将应用层报文交付给应用进程。也就是说UDP对应用进程交下来的报文**既不合并也不拆分**，而是保留这些报文的边界，所以**UDP是面向应用报文的**

**TCP：** 

​	**发送方**的TCP把应用进程交付下来的数据块仅仅看作是**一连串的无结构的字节流**，TCP并不知道这些待传送的字节流的含义，仅将它们编号并存储在自己的**发送缓存**中，TCP根据发送策略从发送缓存中**提取一定数量的字节**构建**TCP报文段**并发送。**接收方**的TCP一方面从所接收到的TCP报文段中**取出数据载荷部分**并存储到**接收缓存**中，另一方面将接收缓存中的一些字节交付给应用进程。

​	TCP不保证接收到的数据块与发送方应用进程发出的数据块具有对应大小的关系。Eg. 发送方应用进程交给发送方的TCP共10个数据块，但接收方的数据块可能只用了4个数据块就把收到的字节流交付给上层的应用进程，但接收方应用进程收到的字节流**必须和发送方应用进程发出的字节流完全一样**。同时，接收方的应用进程必须有能力识别收到的字节流并把它还原成有意义的应用层数据，也就是说**TCP是面向字节流的**，这正是**TCP实现可靠传输、流量控制以及拥塞控制的基础**

![image-20240331200646664](Images\image-20240331200646664.png)

****

***传输是否可靠***

**UDP:** 

​	UDP向上提供无连接不可靠的传输服务，若传输过程中用户数据报受到干扰产生误码，接收方UDP可以通过该数据报首部中的**校验和字段**的值检查出产生误码的情况，但**仅仅丢弃该数据报**。发送方给接收方发送UDP用户数据报，如果该数据报被因特网中的某个路由器丢弃了，**发送方UDP不做任何处理**。基于UDP的这种性质，UDP**适用于实时应用**，例如IP电话，视频会议等

**TCP：**

​	尽管网络层的IP协议向上提供的是无连接不可靠的传输服务，即IP数据报在传输过程中可能出现丢失或误码，但**只要运输层使用TCP协议就可向上层提供面向连接的可靠传输服务**。使用TCP协议的收发双方基于TCP连接的可靠信道进行数据传输，不会出现误码、丢失、乱序以及重复等传输差错。基于TCP的这种性质，TCP**适用于要求可靠传输的应用**，例如文件传输

![](Images\image-20240331202554157.png)

****

***报文首部***

![image-20240331202755289](Images\image-20240331202755289.png)



### 5.4 TCP的流量控制

**导引：**一般来说，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能**来不及接收**，这就会造成数据的丢失。

**定义：** **流量控制(flow control)**就是让发送方的发送速率不要太快，要让接收方来得及接收。

利用**滑动窗口机制**可以很方便地在TCP连接上实现对发送方的流量控制：

- TCP接收方利用自己的**接收窗口**的大小来限制发送方**发送窗口**的大小。
- TCP发送方收到接收方的**零窗口通知**后，应启动**持续计时器**。持续计时器超时后，向接收方发送**零窗口探测报文**。



### 5.5 TCP的拥塞控制

**导引：**

- 在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分**，**网络性能就要变坏**。这种情况就叫做**拥塞**(congestion)
  - 在计算机网络中的链路容量(即带宽)、交换结点中的缓存和处理机等，都是网络的资源。
- 若**出现拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**。

<img src="Images\image-20240331205140869.png" alt="image-20240331205140869" style="zoom:67%;" />

​	拥塞控制用到了四种算法，分别是**慢开始，拥塞避免，快重传，快恢复**，为了介绍这四种拥塞控制算法的基本原理，**假定如下条件**:

- 数据是单方向传送，而另一个方向只传送确认。
- 接收方总是有足够大的缓存空间，因而**发送方发送窗口的大小由网络的拥塞程度来决定**。
- 以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。



#### 5.5.1 慢开始和拥塞避免

发送方维护一个叫做**拥塞窗口cwnd**的状态变量，其值**取决于网络的拥塞程度**，并且**动态变化**：

-  拥塞窗口cwnd的**维护原则**：
  - 只要网络**没有出现拥塞，拥塞窗口**就再**增大**一些（**慢慢试探**）;
  - 只要网络**出现拥塞，拥塞窗口就减少**一些（**收敛一些**）；
- 判断出现网络拥塞的依据:没有按时收到应当到达的确认报文(即发生超时重传)

发送方将拥塞窗口作为**发送窗口swnd**，即swnd=cwnd，并且维护一个**慢开始门限ssthresh**状态变量:

- 当cwnd<ssthresh时，使用**慢开始算法**;

- 当cwnd >ssthresh时，停止使用慢开始算法而改用拥塞避免算法:

- 当cwnd=ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。

<img src="Images\image-20240331210514620.png" alt="image-20240331210514620" style="zoom: 67%;" />

<img src="Images\image-20240331210845270.png" alt="image-20240331210845270" style="zoom:67%;" />



<img src="Images\image-20240331211141419.png" alt="image-20240331211141419" style="zoom:67%;" />

**“慢开始”**是指一开始向网络注入的报文段少，并**不是指拥塞窗口cwnd增长速度慢**;

**“拥塞避免”**并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，**使网络比较不容易出现拥塞**

****

**比较生动的例子：**

**慢开始**（比较**大胆的试探**）

**拥塞避免**（感觉可能到极限了，**谨慎的试探**），当拥塞避免时出现**超时重传**就要**重新评估**可以进行大胆试探的区间

****

#### 5.5.2 快重传和快恢复

​	虽然慢开始和拥塞避免较好的进行了拥塞控制，但是只用慢开始和拥塞避免带来了一个问题：

​	因为拥塞避免当**超时重传**就将拥塞窗口重新置为1，其背后假定超时重传一定是拥塞导致的，但是有时也有**可能是报文段丢失导致**的，这时如果**错误的启动慢开始算法就会降低传输效率**，为了解决这一问题设计了**快重传和快恢复**两个算法



快重传，就是使发送方**尽快进行重传**，而**不是等超时重传计时器超时**再重传。

- 要求接收方不要等待自己发送数据时才进行捎带确认，而是要**立即发送确认**;
- 即使收到了失序的报文段也要立即发出对已收到的报文段的**重复确认**；
- 发送方一旦**收到3个连续的重复确认**，就将相应的报文段**立即重传**，而不是等该报文段的超时重传计时器超时再重传。
- 对于个别丢失的报文段，发送方**不会出现超时重传，也就不会误认为出现了拥塞**（进而降低拥塞窗口cwnd为1）。使用快重传可以使整个网络的吞吐量提高约20%。

<img src="Images\image-20240331212546390.png" alt="image-20240331212546390" style="zoom:67%;" />



发送方**收到3个重复确认**，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而**执行快恢复算法**：

- 发送方将**慢开始门限**ssthresh值和**拥塞窗口**cwnd值调整为**当前窗口的一半**；开始**执行拥塞避免**算法。
- 有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh +3.
  - 既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络;
  - 这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中;
  - 可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。

![image-20240331214035944](Images\image-20240331214035944.png)



### 5.6 TCP超时重传时间的选择

**超时重传时间（RTO）的选择是TCP最复杂的问题之一**

<img src="Images\image-20240331221154208.png" alt="image-20240331221154208" style="zoom:80%;" />

<img src="Images\image-20240331221323244.png" alt="image-20240331221323244" style="zoom:80%;" />

 ![image-20240331221631015](Images\image-20240331221631015.png)

![image-20240331221851962](Images\image-20240331221851962.png)



![image-20240331222220620](Images\image-20240331222220620.png)



### 5.7 TCP可靠传输的实现

TCP基于**以字节为单位的滑动窗口**来实现可靠传输

![image-20240331222940965](Images\image-20240331222940965.png)

**前沿向后收缩是一个特别不好的事情**，因为在接收方发送的接收窗口改变的通知到达前发送方就可能已经发送很多数据了，将前沿后移可能会导致部分已发送的字段被重复发送

![image-20240331225111543](Images\image-20240331225111543.png)

​	虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口并不总是和接收方的接收窗口**一样大：

- 网络传送窗口值需要经历一定的**时间滞后**，并且这个时间还是不确定的；
- 发送方还可能**根据网络当时的拥塞情况适当减小自己的发送窗口尺寸**；

****

​	对于**不按序到达的数据应如何处理**，TCP并无明确规定：

- 如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利因为发送方会重复传送较多的数据。
- TCP通常对不按序到达的数据是**先临时存放在接收窗口**中，等到字节流中所缺少的字节收到后，再**按序交付上层的应用进程**。

****

​	TCP要求接收方必须有**累积确认和捎带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上：

- **接收方不应过分推迟发送确认**，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源：
  - TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报
    文段就发送一个确认。

- 捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

****

​	**TCP的通信是全双工通信**。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。

<img src="Images\image-20240331230444906.png" alt="image-20240331230444906" style="zoom: 67%;" />



### 5.8 TCP的运输连接管理

<img src="Images\image-20240331230726836.png" alt="image-20240331230726836" style="zoom:67%;" />

#### 5.8.1 TCP的连接建立（三次握手）

TCP的连接建立要解决以下三个问题：

- 使TCP双方能够确知对方的存在；
- 使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等)；
- 使TCP双方能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配；

****

 ![image-20240331232102521](Images\image-20240331232102521.png)

**问：为什么TCP客户进程最后还要发送一个普通的TCP确认报文段呢？（可以用两次握手吗）**

假如是两次握手，可能出现如下情况：

- **连接状态的不确定性**：在只有两次握手的情况下，服务器无法确切知道客户端是否收到了它的应答和连接确认，这可能会导致服务器认为连接已经建立，而客户端却没有准备好，从而导致数据传输失败或者连接挂起。
- **重复的旧连接请求**：如果客户端发送的连接请求（SYN）因为网络延迟而迟迟未到达服务器，客户端可能会重新发送连接请求。如果只有两次握手，服务器收到延迟的第一个连接请求时，会认为是新的连接请求并建立连接，这可能导致服务器资源被无效或旧的连接请求占用，如下图所示：

![image-20240331233912720](Images\image-20240331233912720.png)



#### 5.8.2 TCP的连接释放（四次挥手）

![image-20240331235509679](Images\image-20240331235509679.png)

**问：TCP客户进程发送最后一个确认报文段后为什么不直接进入关闭状态？**

​	客户进程发送的确认报文段可能在传输中丢失，这时服务器超时重传TCP连接释放报文段。如果客户进程已经关闭了会导致服务器永远无法收到确认报文段，也就无法关闭连接。



**问：连接建立后，如果客户进程出现故障无法正常进行通信，TCP服务器进程该如何发现这种情况？**

​	使用**保活计时器**（比如心跳包），若保活计时器定时周期内未收到TCP客户进程发来的数据，则**当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段**，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。

### 5.9 TCP报文段的首部格式

## 6. 应用层

![image-20240401000848873](Images\image-20240401000848873.png)

### 6.1 C/S方式和P2P方式

![image-20240401021814504](Images\image-20240401021814504.png)

### 6.2 动态主机配置协议DHCP

### 6.3 域名系统DNS

![image-20240401023043734](Images\image-20240401023043734.png)

![image-20240401023331865](Images\image-20240401023331865.png)

![image-20240401023539934](Images\image-20240401023539934.png)

![image-20240401023909507](Images\image-20240401023909507.png)

![image-20240401024129080](Images\image-20240401024129080.png)

![image-20240401024311447](Images\image-20240401024311447.png)

![image-20240401024353972](Images\image-20240401024353972.png)



### 6.4 文件传送协议FTP

![image-20240401024635323](Images\image-20240401024635323.png)

### 6.5 万维网www

![image-20240401031355572](Images\image-20240401031355572.png)



#### 6.5.1 超文本传输协议HTTP

​	HTTP定义了浏览器(即万维网客户进程)怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维
网文档传送给浏览器。

<img src="Images\image-20240401032041003.png" alt="image-20240401032041003" style="zoom:67%;" />

​	**HTTP/1.0**采用**非持续连接方式**。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接当收到响应后就立即关闭连接。

- **每请求一个文档就要有两倍的RTT的开销**。若一个网页上有很多引用对象(例如图片等)，那么请求每一个对象都需要花费2RTT的时间。
- 为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。

<img src="Images\image-20240401032330845.png" alt="image-20240401032330845" style="zoom:67%;" />

​	**HTTP/1.1**采用**持续连接**方式。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。

- 为了进一步提高效率，HTTP/1.1的持续连接还可以使用**流水线**方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少，提高了下载文档的效率。

****

***HTTP报文格式***

![image-20240401032756502](Images\image-20240401032756502.png)
