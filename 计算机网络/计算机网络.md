# 计算机网络

[TOC]

## 1. 简述

## 2. 物理层

## 3. 数据链路层

## 4. 网络层

### 4.1 概述

### 4.2 网络层提供的两种服务

### 4.3 IPv4

#### 4.3.1 IPv4概述

#### 4.3.2 分类编制的IPv4地址

#### 4.3.3 划分子网的IPv4地址

#### 4.3.4 无分类编制的IPv4地址

### 4.4 IP数据报的发送和转发过程

IP数据报的发送和转发过程包含以下两部分：

- 主机发送IP数据报；
- 路由器转发IP数据报；

路由器隔离广播域来避免**广播风暴**，同时也能隔离冲突域

IP路由器对收到的IP分组头进行差错校验，当发现错误时会丢弃该IP分组并向源主机发送**ICMP差错报告**报文



**主机发送IP数据报**

- **判断目的主机是否与自己在同一个网络**，将目的主机IP地址与自己的子网掩码**相与（&）**，如果网络号和自己的一致则说明在同一个网络，否则不在
  - 若**在同一个网络**，则属于**直接交付**
  - 若**不在同一个网络**，则属于**间接交付**，传输给主机所在网络的**默认网关**(路由器)，由默认网关帮忙转发:



**路由器转发IP数据报**

- **检查IP数据报首部是否出错：**
  - 若出错，则直接丢弃该IP数据报并通告源主机;
  - 若没有出错，则进行转发;
- **根据IP数据报的目的地址在路由表中查找匹配的条目**(查找方法请参看本节课相关示例)：
  - 若找到匹配的条目，则转发给条目中指示的下一跳;
  - 若找不到，则丢弃该IP数据报并通告源主机;



### 4.5 静态路由配置及其可能产生的路由环路问题

- 静态路由配置是指用户或网络管理员使用路由器相关命令给路由器**人工配置路由表**。

  - 这种人工配置方式简单、开销小。但**不能及时适应网络状态(流量、拓扑等)的变化；**

  - 一般只在小规模网络中采用；

- 使用静态路由配置可能出现以下**导致**产生**路由环路**的错误
  - 配置错误
  - 聚合了不存在的网络
  - 网络故障

![image-20240409043125572](Images\image-20240409043125572.png)

![image-20240409043359510](Images\image-20240409043359510.png)

![image-20240409044609593](Images\image-20240409044609593.png)



![image-20240409044847204](Images\image-20240409044847204.png)

![image-20240409045309791](Images\image-20240409045309791.png)

针对聚合了不存在的网络导致的路由环路问题，可以添加针对所聚合的、不存在的网络的**黑洞路由**，黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，可以形象的看作一个黑洞，IP数据报进入后就有去无回了，也就是路由器丢弃了该IP数据报

![image-20240409045749630](Images\image-20240409045749630.png)



### 4.6 路由选择协议

#### 4.6.1 概述

![image-20240409051039955](Images\image-20240409051039955.png)

![image-20240409051413435](Images\image-20240409051413435.png)

![image-20240409052350650](Images\image-20240409052350650.png)

域间路由选择使用**外部网关协议EGP**，域内路由选择使用**内部网关协议IGP**，需要说明的是外部网关协议EGP和内部网关协议IGP只是路由选择协议的**分类名称**，而**不是具体的路由选择协议**



在一个自治系统**内部使用的具体的内部网关协议**与**因特网中其他自治系统**中选用何种内部网关协议**无关**，如下图所示:

![image-20240409052844502](Images\image-20240409052844502.png)



**常见的路由选择协议：**

![image-20240409054107679](Images\image-20240409054107679.png)

要注意的是，**路由选择协议是在路由器上运行的**



**路由器的基本结构：**

路由器会周期性的给其他路由器发送自己知道的路由信息，接收到路由信息的路由器会根据自己的路由选择协议计算一个最优化的网络拓扑路径更新转发表，当普通的报文经过路由器时，查找转发表找到合适的路径转发

![image-20240409054757998](Images\image-20240409054757998.png)



#### 4.6.2 路由信息协议RIP的基本工作原理

**路由信息协议RIP**(Routing Information Protocol)是内部网关协议IGP中**最先得到广泛使用的协议之一**，其相关标准文档为RFC 1058。

RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为 “**距离向量D-V(Distance-Vector)**“。

RIP使用**跳数**(Hop Count)作为度量(Metric)**来衡量到达目的网络的距离**：

- 路由器到直连网络的距离定义为1；
- 路由器到非直连网络的距离定义为所经过的路由器数加1；
- 允许一条路径最多只能包含15个路由器。**“距离”等于16时相当于不可达**。因此，**RIP只适用于小型互联网**；

![image-20240409055911292](Images\image-20240409055911292.png)

RIP认为**好的路由**就是”距离短“的路由，也就是**所通过路由器数量最少的路由**。如下面几个例子所示：

（1）

![image-20240409060101730](Images\image-20240409060101730.png)

该例子中RIP认为R1到R5的好路由是：R1->R4->R5，**尽管这条路由上各段链路的带宽都非常小**

（2）

![image-20240409060256855](Images\image-20240409060256855.png)

该例子中从R1到R6的两条路径是等价的，此时RIP会采用**等价负载均衡**，也就是将**通信量均衡地分布到多条等价的路由上**



****

**RIP的三个要点：**

- **和谁交换信息**	仅和**相邻路由器**交换信息

![image-20240409060656822](Images\image-20240409060656822.png)

- **交换什么信息**	自己的**路由表**
- **何时交换信息**	**周期性交换**（例如每30秒）

****

**RIP的基本工作过程**

1. 路由器刚开始工作时，**只知道自己到直连网络的距离为1**；
2. 每个路由器仅**和相邻路由器周期性地交换并更新路由信息**；
3. 若干次交换和更新后，**每个路由器都知道到达本AS内各网络的最短距离和下一跳地址**，称为收敛；

<img src="Images\image-20240409061048534.png" alt="image-20240409061048534" style="zoom:67%;" />



****

**RIP的路由条目的更新规则**

如下图所示，路由器C和D是相邻路由器，它们之间周期性地交换并更新路由信息（**类似于Dijkstra算法的松弛操作**）

![image-20240409061700911](Images\image-20240409061700911.png)

![image-20240409061737498](Images\image-20240409061737498.png)

![image-20240409061834395](Images\image-20240409061834395.png)

![image-20240409061927275](Images\image-20240409061927275.png)

![image-20240409062021716](Images\image-20240409062021716.png)

****

**RIP存在 “坏消息传播得慢” 的问题**

![image-20240409062401255](Images\image-20240409062401255.png)

“坏消息传播得慢”又称为**路由环路**或**距离无穷计数**问题，这是**距离向量算法的一个固有问题**可以采取多种措施**减少**出现该问题的概率或减小该问题带来的危害。

- **限制最大路径距离为15**（16表示不可达）
- 当路由表发生变化时就立即发送更新报文（即“**触发更新**”），而不仅是周期性发送
- 让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“**水平分割**”）



#### 4.6.3 开放最短路径优先OSPF的基本工作原理

开放最短路径优先OSPF(0pen Shortest Path First)，是为克服RIP的缺点在1989年开发出来的。

- “开放”表明OSPF协议不是受某一家厂商控制，而是**公开发表**的。
- “最短路径优先”是因为使用了Dijkstra提出的**最短路径算法SPF**。

OSPF是**基于链路状态**的，而不像RIP那样是基于距离向量的。

OSPF采用SPF算法计算路由，从算法上保证了**不会产生路由环路**；

OSPF**不限制网络规模**，更新效率高，**收敛速度快**。

链路状态是指本路由器都**和哪些路由器相邻**，以及相应**链路的“代价”**(cost)

- “代价”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定

![image-20240409063558535](Images\image-20240409063558535.png)

****

**邻居表**

![image-20240409063837047](Images\image-20240409063837047.png)

****

**链路状态通告LSA**

使用OSPF的每个路由器都会产生**链路状态通告LSA**(Link State Advertisement)。LSA中包含以下内容:

- 直连网络的链路状态信息
- 邻居路由器的链路状态信息

LSA被封装在**链路状态更新分组LSU**中，采用**洪泛法**发送。

<img src="Images\image-20240409064129850.png" alt="image-20240409064129850" style="zoom:67%;" />

****

**链路状态数据库LSDB**

使用OSPF的每个路由器都有一个**链路状态数据库LSDB**，用于存储LSA；

通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终将达到一致；

![image-20240409064526457](Images\image-20240409064526457.png)

****

**构建路由表**

![image-20240409064705004](Images\image-20240409064705004.png)

****

**分组类型**

![image-20240409064857228](Images\image-20240409064857228.png)

****

**OSPF的基本工作过程**

![image-20240409065127657](Images\image-20240409065127657.png)

![image-20240409065427751](Images\image-20240409065427751.png)

![image-20240409065737756](Images\image-20240409065737756.png)

**用来减少交换信息的通信量**



#### 4.6.4 边界网关协议BGP的基本工作原理

![image-20240409070037616](Images\image-20240409070037616.png)

![image-20240409070236046](Images\image-20240409070236046.png)

![image-20240409070418951](Images\image-20240409070418951.png)

![image-20240409070527267](Images\image-20240409070527267.png)

![image-20240409070641428](Images\image-20240409070641428.png)

![image-20240409070757721](Images\image-20240409070757721.png)



## 5. 运输层

### 5.1 概述

​	计算机网络体系结构中的**物理层、数据链路层以及网络层**它们共同解决了将主机通过异构网络互联起来所面临的问题，**实现了主机到主机的通信**。

​	但实际上在计算机中进行**通信的真正实体是位于通信两端主机中的进程**。

​	**如何为运行在不同主机上的应用进程（AP）提供直接的通信服务是运输层的任务**，运输层协议又称为端到端协议

![image-20240330213528226](Images\image-20240330213528226.png)

​	假设AP1和AP4之间，AP2和AP3之间进行基于网络的通信，在运输层使用**不同的端口**对于不同的应用进程，通过网络层及其下层来传输应用层报文，接收方的运输层**通过不同的端口将收到的应用层报文交付给应用层中相应的应用进程**。需要注意的是，这里的**端口是指用来区分不同应用进程的标识符**，可以简单的认为**运输层直接为应用进程间的逻辑通信提供服务**

**逻辑通信：**运输层之间的通信好像是沿水平方向传送数据，但事实上两条运输层之间并没有一条水平方向的物理连接，**运输层向高层用户屏蔽了网络核心的细节**（如网络拓扑，所采用的路由选择协议等）。

​	根据应用需求的不同，**因特网的运输层**为应用层提供了两种不同的运输协议，即**面向连接的TCP**和**无连接的UDP**，这两种协议就是本章讨论的主要内容。

![image-20240330220146188](Images\image-20240330220146188.png)

### 5.2 端口号，复用与分用

#### 5.2.1 端口号

**定义：**

​	与本地进程通信（IPC）使用进程标识符PID来标识不同进程不同，远程进程通信（RPC）使用**端口号来标识不同的进程。** 这是因为因特网上的计算机使用的并不是统一的操作系统，**不同的操作系统有不同格式的PID**，为了使这些使用不同操作系统的计算机的应用进程能进行通信就**必须定义一个统一的格式对TCP/IP体系的应用程序进行标识**，这就是端口号存在的意义



**端口号使用16比特表示，取值范围0~65535：**

- **熟知端口号：** **0~1023**，互联网数字分配机构（IANA）把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如:FTP使用21/20，HTTP使用80，DNS使用53；
- **登记端口号：**1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定
  的手续登记，以防止重复。例如:Microsoft RDP 微软远程桌面使用的端口是3389；
- **短暂端口号：**49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的**动态端口号**。通信结束后，这个端口号可供其他客户进程以后使用；

​	**端口号只具有本地意义**，即端口号只是为了**标识本计算机应用层中的各进程**，在因特网中**不同计算机中的相同端口号是没有联系的**



#### 5.2.2 发送方的复用和接收方的分用

***复用：与发送方有关***

- **UDP复用：** **发送方**发送的应用报文在运输层使用UDP协议进行封装，这称为UDP复用；
- **TCP复用：** **发送方**发送的应用报文在运输层使用TCP协议进行封装，这称为TCP复用；
- **IP复用：**运输层使用端口号来区分不同的应用进程，不管**发送方**使用运输层的UDP协议封装成的**UDP用户数据报**，还是使用TCP协议封装成的**TCP报文段**，在**网络层**都需要**使用IP协议封装成IP数据报**，这称为IP复用。根据**协议字段的不同来区分**封装的是UDP数据报（17）还是TCP报文段（6）；



***分用：与接收方有关***

**IP分用：** **接收方**的**网络层**收到IP数据报后进行IP分用，若IP数据报协议字段值为17则把IP数据报的数据载荷部分封装的UDP用户数据报**上交给运输层的UDP**，若值为6则把IP数据报的数据载荷部分封装的TCP报文段上交给**运输层的TCP；**

**UDP分用：** **接收方**对UDP用户数据报进行UDP分用，根据端口号交付给对应的应用进程；

**TCP分用：** **接收方**对TCP报文报进行TCP分用，根据端口号交付给对应的应用进程；

![image-20240330222951053](Images\image-20240330222951053.png)

****

***TCP/IP体系应用层常用协议所使用的运输层熟知端口号***

![image-20240330223139728](Images\image-20240330223139728.png)



### 5.3 UDP和TCP的对比

**UDP**和**TCP**是TCP/IP体系结构**运输层**中的**两个重要协议**，在使用TCP/IP体系结构的网络通信中，UDP和TCP的使用协议仅次于网络层的IP协议

| 用户数据报协议UDP                          | 传输控制协议TCP                                   |
| ------------------------------------------ | ------------------------------------------------- |
| 无连接                                     | 面向连接                                          |
| 支持一对一，一对多，多对一和多对多交互通信 | 每一条TCP连接只能有两个端点，**只能是一对一通信** |
| 对应用层交付的报文直接打包                 | 面向字节流                                        |
| 尽最大努力交付，也就是**不可靠**           | **可靠传输**                                      |
| 不使用流量控制和拥塞控制                   | **使用流量控制和拥塞控制**                        |
| 首部开销小，仅8字节                        | 首部最小20字节，最大60字节                        |

****

***连接的不同*：**

![image-20240331194151250](Images\image-20240331194151250.png)

****

***通信的不同*：**

**UDP：**使用UDP协议进行通信的四台主机，其中任何一台主机都可向其他三台主机发送广播，也可向某个**多播组**发送组播（多播），还可以向某台主机发送单播，也就是说，UDP**支持一对一，一对多以及一对全的通信**

**TCP：**使用TCP协议的通信双方在进行数据传输之前必须使用“三报文握手”建立TCP连接，建立成功后，通信双方之间就**好像有一条可靠的通信信道**，通信双方使用这条基于TCP连接的可靠信道进行通信，因此**TCP仅支持单播，也就是一对一的通信**

![image-20240331195120763](Images\image-20240331195120763.png)

****

***应用报文的处理：***

**UDP：** 

​	**发送方**的应用进程将应用层报文交付给运输层的UDP，UDP直接给应用层报文添加一个UDP首部使之成为**UDP用户数据报**然后进行发送。**接收方**收到该UDP用户数据报后去掉UDP首部，将应用层报文交付给应用进程。也就是说UDP对应用进程交下来的报文**既不合并也不拆分**，而是保留这些报文的边界，所以**UDP是面向应用报文的**

**TCP：** 

​	**发送方**的TCP把应用进程交付下来的数据块仅仅看作是**一连串的无结构的字节流**，TCP并不知道这些待传送的字节流的含义，仅将它们编号并存储在自己的**发送缓存**中，TCP根据发送策略从发送缓存中**提取一定数量的字节**构建**TCP报文段**并发送。**接收方**的TCP一方面从所接收到的TCP报文段中**取出数据载荷部分**并存储到**接收缓存**中，另一方面将接收缓存中的一些字节交付给应用进程。

​	TCP不保证接收到的数据块与发送方应用进程发出的数据块具有对应大小的关系。Eg. 发送方应用进程交给发送方的TCP共10个数据块，但接收方的数据块可能只用了4个数据块就把收到的字节流交付给上层的应用进程，但接收方应用进程收到的字节流**必须和发送方应用进程发出的字节流完全一样**。同时，接收方的应用进程必须有能力识别收到的字节流并把它还原成有意义的应用层数据，也就是说**TCP是面向字节流的**，这正是**TCP实现可靠传输、流量控制以及拥塞控制的基础**

![image-20240331200646664](Images\image-20240331200646664.png)

****

***传输是否可靠***

**UDP:** 

​	UDP向上提供无连接不可靠的传输服务，若传输过程中用户数据报受到干扰产生误码，接收方UDP可以通过该数据报首部中的**校验和字段**的值检查出产生误码的情况，但**仅仅丢弃该数据报**。发送方给接收方发送UDP用户数据报，如果该数据报被因特网中的某个路由器丢弃了，**发送方UDP不做任何处理**。基于UDP的这种性质，UDP**适用于实时应用**，例如IP电话，视频会议等

**TCP：**

​	尽管网络层的IP协议向上提供的是无连接不可靠的传输服务，即IP数据报在传输过程中可能出现丢失或误码，但**只要运输层使用TCP协议就可向上层提供面向连接的可靠传输服务**。使用TCP协议的收发双方基于TCP连接的可靠信道进行数据传输，不会出现误码、丢失、乱序以及重复等传输差错。基于TCP的这种性质，TCP**适用于要求可靠传输的应用**，例如文件传输

![](Images\image-20240331202554157.png)

****

***报文首部***

![image-20240331202755289](Images\image-20240331202755289.png)



### 5.4 TCP的流量控制

**导引：**一般来说，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能**来不及接收**，这就会造成数据的丢失。

**定义：** **流量控制(flow control)**就是让发送方的发送速率不要太快，要让接收方来得及接收。

利用**滑动窗口机制**可以很方便地在TCP连接上实现对发送方的流量控制：

- TCP接收方利用自己的**接收窗口**的大小来限制发送方**发送窗口**的大小。
- TCP发送方收到接收方的**零窗口通知**后，应启动**持续计时器**。持续计时器超时后，向接收方发送**零窗口探测报文**。



### 5.5 TCP的拥塞控制

**导引：**

- 在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分**，**网络性能就要变坏**。这种情况就叫做**拥塞**(congestion)
  - 在计算机网络中的链路容量(即带宽)、交换结点中的缓存和处理机等，都是网络的资源。
- 若**出现拥塞而不进行控制**，整个网络的**吞吐量将随输入负荷的增大而下降**。

<img src="Images\image-20240331205140869.png" alt="image-20240331205140869" style="zoom:67%;" />

​	拥塞控制用到了四种算法，分别是**慢开始，拥塞避免，快重传，快恢复**，为了介绍这四种拥塞控制算法的基本原理，**假定如下条件**:

- 数据是单方向传送，而另一个方向只传送确认。
- 接收方总是有足够大的缓存空间，因而**发送方发送窗口的大小由网络的拥塞程度来决定**。
- 以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。



#### 5.5.1 慢开始和拥塞避免

发送方维护一个叫做**拥塞窗口cwnd**的状态变量，其值**取决于网络的拥塞程度**，并且**动态变化**：

-  拥塞窗口cwnd的**维护原则**：
  - 只要网络**没有出现拥塞，拥塞窗口**就再**增大**一些（**慢慢试探**）;
  - 只要网络**出现拥塞，拥塞窗口就减少**一些（**收敛一些**）；
- 判断出现网络拥塞的依据:没有按时收到应当到达的确认报文(即发生超时重传)

发送方将拥塞窗口作为**发送窗口swnd**，即swnd=cwnd，并且维护一个**慢开始门限ssthresh**状态变量:

- 当cwnd<ssthresh时，使用**慢开始算法**;

- 当cwnd >ssthresh时，停止使用慢开始算法而改用拥塞避免算法:

- 当cwnd=ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。

<img src="Images\image-20240331210514620.png" alt="image-20240331210514620" style="zoom: 67%;" />

<img src="Images\image-20240331210845270.png" alt="image-20240331210845270" style="zoom:67%;" />



<img src="Images\image-20240331211141419.png" alt="image-20240331211141419" style="zoom:67%;" />

**“慢开始”**是指一开始向网络注入的报文段少，并**不是指拥塞窗口cwnd增长速度慢**;

**“拥塞避免”**并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，**使网络比较不容易出现拥塞**

****

**比较生动的例子：**

**慢开始**（比较**大胆的试探**）

**拥塞避免**（感觉可能到极限了，**谨慎的试探**），当拥塞避免时出现**超时重传**就要**重新评估**可以进行大胆试探的区间

****

#### 5.5.2 快重传和快恢复

​	虽然慢开始和拥塞避免较好的进行了拥塞控制，但是只用慢开始和拥塞避免带来了一个问题：

​	因为拥塞避免当**超时重传**就将拥塞窗口重新置为1，其背后假定超时重传一定是拥塞导致的，但是有时也有**可能是报文段丢失导致**的，这时如果**错误的启动慢开始算法就会降低传输效率**，为了解决这一问题设计了**快重传和快恢复**两个算法



快重传，就是使发送方**尽快进行重传**，而**不是等超时重传计时器超时**再重传。

- 要求接收方不要等待自己发送数据时才进行捎带确认，而是要**立即发送确认**;
- 即使收到了失序的报文段也要立即发出对已收到的报文段的**重复确认**；
- 发送方一旦**收到3个连续的重复确认**，就将相应的报文段**立即重传**，而不是等该报文段的超时重传计时器超时再重传。
- 对于个别丢失的报文段，发送方**不会出现超时重传，也就不会误认为出现了拥塞**（进而降低拥塞窗口cwnd为1）。使用快重传可以使整个网络的吞吐量提高约20%。

<img src="Images\image-20240331212546390.png" alt="image-20240331212546390" style="zoom:67%;" />



发送方**收到3个重复确认**，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而**执行快恢复算法**：

- 发送方将**慢开始门限**ssthresh值和**拥塞窗口**cwnd值调整为**当前窗口的一半**；开始**执行拥塞避免**算法。
- 有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh +3.
  - 既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络;
  - 这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中;
  - 可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。

![image-20240331214035944](Images\image-20240331214035944.png)



### 5.6 TCP超时重传时间的选择

**超时重传时间（RTO）的选择是TCP最复杂的问题之一**

<img src="Images\image-20240331221154208.png" alt="image-20240331221154208" style="zoom:80%;" />

<img src="Images\image-20240331221323244.png" alt="image-20240331221323244" style="zoom:80%;" />

 ![image-20240331221631015](Images\image-20240331221631015.png)

![image-20240331221851962](Images\image-20240331221851962.png)



![image-20240331222220620](Images\image-20240331222220620.png)



### 5.7 TCP可靠传输的实现

TCP基于**以字节为单位的滑动窗口**来实现可靠传输

![image-20240331222940965](Images\image-20240331222940965.png)

**前沿向后收缩是一个特别不好的事情**，因为在接收方发送的接收窗口改变的通知到达前发送方就可能已经发送很多数据了，将前沿后移可能会导致部分已发送的字段被重复发送

![image-20240331225111543](Images\image-20240331225111543.png)

​	虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口并不总是和接收方的接收窗口**一样大：

- 网络传送窗口值需要经历一定的**时间滞后**，并且这个时间还是不确定的；
- 发送方还可能**根据网络当时的拥塞情况适当减小自己的发送窗口尺寸**；

****

​	对于**不按序到达的数据应如何处理**，TCP并无明确规定：

- 如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利因为发送方会重复传送较多的数据。
- TCP通常对不按序到达的数据是**先临时存放在接收窗口**中，等到字节流中所缺少的字节收到后，再**按序交付上层的应用进程**。

****

​	TCP要求接收方必须有**累积确认和捎带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上：

- **接收方不应过分推迟发送确认**，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源：
  - TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报
    文段就发送一个确认。

- 捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

****

​	**TCP的通信是全双工通信**。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。

<img src="Images\image-20240331230444906.png" alt="image-20240331230444906" style="zoom: 67%;" />



### 5.8 TCP的运输连接管理

<img src="Images\image-20240331230726836.png" alt="image-20240331230726836" style="zoom:67%;" />

#### 5.8.1 TCP的连接建立（三次握手）

TCP的连接建立要解决以下三个问题：

- 使TCP双方能够确知对方的存在；
- 使TCP双方能够协商一些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等)；
- 使TCP双方能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配；

****

 ![image-20240331232102521](Images\image-20240331232102521.png)

**问：为什么TCP客户进程最后还要发送一个普通的TCP确认报文段呢？（可以用两次握手吗）**

假如是两次握手，可能出现如下情况：

- **连接状态的不确定性**：在只有两次握手的情况下，服务器无法确切知道客户端是否收到了它的应答和连接确认，这可能会导致服务器认为连接已经建立，而客户端却没有准备好，从而导致数据传输失败或者连接挂起。
- **重复的旧连接请求**：如果客户端发送的连接请求（SYN）因为网络延迟而迟迟未到达服务器，客户端可能会重新发送连接请求。如果只有两次握手，服务器收到延迟的第一个连接请求时，会认为是新的连接请求并建立连接，这可能导致服务器资源被无效或旧的连接请求占用，如下图所示：

![image-20240331233912720](Images\image-20240331233912720.png)



#### 5.8.2 TCP的连接释放（四次挥手）

![image-20240331235509679](Images\image-20240331235509679.png)

**问：TCP客户进程发送最后一个确认报文段后为什么不直接进入关闭状态？**

​	客户进程发送的确认报文段可能在传输中丢失，这时服务器超时重传TCP连接释放报文段。如果客户进程已经关闭了会导致服务器永远无法收到确认报文段，也就无法关闭连接。



**问：连接建立后，如果客户进程出现故障无法正常进行通信，TCP服务器进程该如何发现这种情况？**

​	使用**保活计时器**（比如心跳包），若保活计时器定时周期内未收到TCP客户进程发来的数据，则**当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段**，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。

### 5.9 TCP报文段的首部格式

## 6. 应用层

![image-20240401000848873](Images\image-20240401000848873.png)

### 6.1 C/S方式和P2P方式

![image-20240401021814504](Images\image-20240401021814504.png)

### 6.2 动态主机配置协议DHCP

### 6.3 域名系统DNS

![image-20240401023043734](Images\image-20240401023043734.png)

![image-20240401023331865](Images\image-20240401023331865.png)

![image-20240401023539934](Images\image-20240401023539934.png)

![image-20240401023909507](Images\image-20240401023909507.png)

![image-20240401024129080](Images\image-20240401024129080.png)

![image-20240401024311447](Images\image-20240401024311447.png)

![image-20240401024353972](Images\image-20240401024353972.png)



### 6.4 文件传送协议FTP

![image-20240401024635323](Images\image-20240401024635323.png)

### 6.5 万维网www

![image-20240401031355572](Images\image-20240401031355572.png)



#### 6.5.1 超文本传输协议HTTP

​	HTTP定义了浏览器(即万维网客户进程)怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维
网文档传送给浏览器。

<img src="Images\image-20240401032041003.png" alt="image-20240401032041003" style="zoom:67%;" />

​	**HTTP/1.0**采用**非持续连接方式**。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接当收到响应后就立即关闭连接。

- **每请求一个文档就要有两倍的RTT的开销**。若一个网页上有很多引用对象(例如图片等)，那么请求每一个对象都需要花费2RTT的时间。
- 为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。

<img src="Images\image-20240401032330845.png" alt="image-20240401032330845" style="zoom:67%;" />

​	**HTTP/1.1**采用**持续连接**方式。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。

- 为了进一步提高效率，HTTP/1.1的持续连接还可以使用**流水线**方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少，提高了下载文档的效率。

****

***HTTP报文格式***

![image-20240401032756502](Images\image-20240401032756502.png)



## 7. 网络同步

### 7.1 状态同步

玩家进行的一些操作比如移动，放技能等，这些数据会上传给服务器，**服务器运行游戏代码**给出当前玩家应该更新的位置和技能等，再将数据发送回**所有玩家的客户端**，更新所有玩家客户端结果。

简单来说，服务器负责处理所有数据，客户端只是负责收集操作的信息并展示效果

![image-20240413073640291](Images\image-20240413073640291.png)

### 7.2 帧同步

玩家进行的一些操作比如移动，放技能等数据会上传给服务器，**服务器只是帮忙收集和转发**，不进行数据的计算，将一段**固定时间**内**所有玩家的发来的数据打包为一个数据帧**转发给所有客户端，**每个客户端收到服务器发送过来的数据后在本地进行计算**，更新自己的客户端结果

帧同步可能导致两个客户端计算结果不一致，同时因为是在本地进行计算，所以对于作弊的检查和处理要比状态同步困难

![image-20240413074329360](Images\image-20240413074329360.png)

### 7.3 上面两个在反作弊、断线重连、实时性等等场合，用哪种同步策略好



### 7.4 TCP和UDP应用上的区别和游戏开发中的使用偏向



## 8. 网络性能的四大指标

### 8.1 带宽

> **带宽，**在网络世界里，是多指数字信号，在规定的时间内，从一端传输到另一端的数据量，即数据传输率。

可以类似于现实生活中的马路，马路越宽吞吐量越高

计算机网络的带宽是指网络可通过的最高数据率，即**每秒多少比特**（常用的单位是bps(bit per second)）。



### 8.2 时延（延迟）

> **时延：**其实就是时间的意思，指报文从A传输到B所需的**时间**。好比如，快递从深圳发出寄到北京需要1天，那么时延就等于1天。

举个例子，如果A的报文到达B花费了6ms，那么此时A的时延就是6ms
$$
总时延 = 发送时延+传播时延+处理时延+排队时延
$$

#### 8.2.1 发送时延

电脑、网络设备把数据包队列发到链路上所学的时间，就是发送时延。

假设报文的长度为L，路由器A把该报文传输到链路上的速率为V，则发送时延为L/V，发送时延通常在毫秒到微秒级。



#### 8.2.2 处理时延

是指网络设备，如交换机、路由器，**收到报文后进行解析所需要的时间，**比如解封装分析首部，查找路由表、路由策略等，处理时延通常是微秒或更低的数量级。



#### 8.2.3 排队时延

排队时延，即当网络设备（路由器、交换机等）收到多个报文时，来不及处理，会先放到缓存队列，所有数据包进行排队，等待处理，这个等待的时间即为排队时延。 排队时延的长度取决于队列中是否有其他数据包，

好比如红绿灯路口，虽然当前是绿灯，但是前面如果有很多车辆，这时就无法立即通过路口，需要排队，缓慢通过路口。如果没有车辆，又是绿灯，则无需排队，直接通过，此时排队时延视为0；

网络时间的排队时延也是一样的，如果队列没有其他报文，此时排队时延就为0；如果报文很多，流量太大了，网络设备来不及处理，就需要进行排队等候处理，所以排队时延就会很大。



#### 8.2.4 传播时延

传播时延，指报文在**实际（有线、无线）链路上传播数据所需要的时间**。

假设路由器A到路由器B的传播时延为t，A到B之间的链路长度为L，数据包在链路上的传播速率为v，则t=L/v。通常传播时延都是在毫秒级的，如果是秒级以上，那传播时延太大了，人类会无法忍受这种速率，太卡了。



### 8.3 抖动

平常，我们坐车的时候，一定遇到过 颠簸的路段，坐在车里能够很明显地感受到这种抖动。



网络也是有抖动的，所谓抖动，就是偏离了预期的时延，即不稳定的时延，网络抖动主要是指最大延迟与最小延迟的时间差。
$$
网络抖动=最大时延-最小时延
$$
例如，你刷抖音，观看一个视频最大延迟是12ms，最小延迟是4ms，那么该网络抖动就是8ms。

你想想看，当年在观看视频，一会儿卡顿，一会儿流畅，此时的你，是不是各种“问候”运营商！！！简直无法忍受！！！

所以说，**要评价网络稳定性，离不开抖动这个指标**，越小的抖动，网络越稳定。

网络抖动是无法完全消除的，受环境变化影响。如干扰、网络拥塞情况等，都可造成网络抖动。



### 8.4 丢包

**丢包，**我联想到就是快递，比如龙哥通过某快递公司，寄了五本书给粉丝，从深圳寄到河北，结果粉丝只收到3本，那其余2本被快递小哥弄丢了。 学网络，就是这么有趣，简单易学，入门没有门槛。所以，网络丢包，也是一样的，就是指数据包从一端被传输到另一端过程中，部分数据未能到达目的地。不过，接收端如果发现数据丢失，可以根据序列号向源端发出“重传请求”。



造成丢包的原因有很多，比如 设备网卡处理不了过多的数据，网络拥塞、就会发生丢包。

所谓的**丢包率**，就是丢失数据包总的数量 占 总发出的数据包数量的 比率。
